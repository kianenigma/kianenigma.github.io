[
{
		"title": "About",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/about/",
		"content": "ü¶Ä Engineering Lead / Rust Core Developer @paritytech\n\nMatrix: @kianenigma:parity.io\nEmail: hello at kianenigma dot com\n\nüî¥ Polkadot Fellow\n\nPolkadot Address: 1eTPAR2TuqLyidmPT9rMmuycHVm9s9czu78sePqg2KHMDrE\nKusama Address: HL8bEp8YicBdrUmJocCAWVLKUaR2dd1y6jnD934pbre3un1\n\nMember of GrayMatter, implementing the graypaper, specification of the Polkadot JAM upgrade.\nüìö Parallel and Distributed Systems Msc. graduate from Vrije Universiteit Amsterdam\n\nThesis: GitHub - kianenigma/SonicChain: A wait-free, pseudo-static approach toward concurrency in blockchain runtimes üöÄ.\n\nüêô Github | Twitter | Linkedin | ResearchGate | Youtube\nüéß <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/playlist/\">Playlists</a> | Spotify\nüì∏ Personal <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/gallery/\">Gallery</a>",
		"tags": [ "note"]
},

{
		"title": "Home",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "You can follow me directly via your email below. I may send occasional updates about my latest writings directly to you. You can find other ways to follow me in <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/about/\">About</a> or via RSS.\n\nLatest Posts (<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/posts-index/\">All Posts</a>)\n\nFile\nDate\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/sharded-and-non-sharded-tps-in-blockchains/\">Sharded and Non-Sharded TPS in Blockchains</a>\nFeb 11 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-sdk-2024/\">Polkadot SDK 2024 Roundup</a>\nNov 22 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/multichain-api/\">Multi-Chain SDK Vision</a>\nSep 04 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/sadi/\">Sa'di</a>\nJul 26 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/on-documenting-polkadot-sdk/\">On Documenting polkadot-sdk</a>\nJul 10 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/\">Demystifying JAM</a>\nMay 02 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/uneducated-unaffiliated-disinterested/\">Uneducated, Unaffiliated, Disinterested</a>\nMar 30 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/gallery/\">Gallery</a>\nMar 30 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/meta-cognition-framework/\">Meta Cognition Framework</a>\nMar 24 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/the-price-of-change/\">The Price of Change</a>\nMar 23 2024\n\nLatest Talks (<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/talks-index/\">All Talks</a>)\n\nFile\nDate\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/presentation-pba/\">Demystifying JAM - PBA6</a>\nApr 01 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2025/smart-contracts-101/\">Smart Contracts 101</a>\nJan 13 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2024/podcast-kusamarian/\">Podcast - Kusamarian</a>\nJan 05 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2024/plaza-polkadot-hub-open-giuld-community-call/\">Plaza Polkadot Hub - OpenGiuld Community Call</a>\nDec 13 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/multichain/\">Building Bridges and Ecosystems - Devcon 2024</a>\nNov 22 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/presentation/\">Demystifying JAM - Presentation</a>\nNov 06 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/frame-2024/\">Polkadot-SDK FRAME @ 2024</a>\nNov 06 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/blockchain-reimagined/presentation-tum/\">Blockchain Scalability - A Holistic Recap</a>\nSep 08 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2024/polkadot-blockchain-academy-hong-kong/\">Polkadot Blockchain Academy Hong Kong</a>\nJun 27 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/nomination-pools/\">Nomination Pools</a>\nAug 28 2023",
		"tags": [ "note","gardenEntry"]
},

{
		"title": "Amsterdam BunkerTalks Experience 1",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/amsterdam-bunker-talks-experience-1/",
		"content": "Some time ago I went to a BunkerTalk in Amsterdam about Iran's political situation and human right issues. The words that are being said in such events should be pretty clear to you, so I will\nrephrase it in the easiest possible:\nIt is bad. Iran is moving fast toward becoming one of the most suppressive governments in the world and things are not looking good for the people living there.\nGiven the context, you can imagine that this gathering in Amsterdam among Iranians living here would be pretty much straight forward: Everyone agreeing that Iran sucks. Except.. I was also there and almost toward the end, after an hour of bashing Iran's right-wing politicians, I raised my hand to add a comment.\nI started by saying that I totally agree with everything said about Iran. Of course,\neveryone forgot about this about 30 seconds later. Anyways: I continued by arguing that: We must remember that everyone is to some extent deluded and affected by what story and fiction we decide to believe in. Me and most people who are reading this probably agree on human rights, equality, no gender discrimination and freedom of speech. Iran's version of Islam is to some extent against all of these. But we should not forget that they are also merely putting their faith in some story. Same as I am doing. Same as you are doing. In other words, they also deeply believe that they are doing the right thing. It is merely a matter of opinion.\nI can elaborate a bit more. I grew up in Iran. Islam and the absolute necessity of belief in it is\nput into your head from the day that you are born (literally). This, eventually, becomes your\nframework of life. Luckily, I was able to break out of this from a young age. Nowadays, thanks to the internet and more and more information being circulated, more and more people break out. But still, Many don't. All of those who join the IRGC, those that become the moral police, they simply never break out of this framework and it is all they know to life. And if you\ndon't, In such a society, you never grow the wisdom to think outside of this framework. This is how regardless of how horrible someone's actions might be, in the eyes of me or you as a liberal person, they still think they are doing the right person. Those forces who attack demonstrators in the streets of Tehran pretty frequently (and very often killing a few dozens), they also think they are doing the right thing. They surely believe that god will forgive them for doing this. Same goes for many of our politicians who still make wrong decisions. Same probably goes for the poor person who mistook an airplane for a missile and accidentally killed 176 people in a second.\nNow, I am not saying these people are not to be held responsible for their actions. Nor do I claim that what they do is justifiable. What I am saying is that we should confront them, in any way that we are confronting them, whilst remembering what I said above: Most often they have simply been fed the wrong story (if you want to be more objective: just a different story). And they are probably miserable deep down, but can't break out of their current mindset.\nIf we really think that they are wrong and we are right, the burden of enlightening them is\nactually upon us. We should not fight back as if they are our enemy and as if they are wrong and we are right. We should not claim the moral high ground. No, they are just wrong, and remember, miserable.\n\nI don't recall the words that I said that evening, but the gist it is the above few paragraphs. And\nthe response that I got was: &quot;I cannot think about enlightening someone one a gun is being held at my forehead&quot;. I had two counter arguments to this response, but sadly the tone of the night was such that I decided to not continue. After this answer, everyone applauded the response and I was asked by another attendant to not continue and that my comment was misplaced. But the answers that I would have told:\n\nThis is a pure emotional reaction, not a rational answer. That man who said that was an\natheist. And I know living in Iran must have been hard for him. And maybe at some point a gun was being pointed to his face. But not that day. And in that day, now that no gun is being held at anyone of us, we should decide to think rationally rather than clinging into past emotions.\nBut all in all, I see that what I am proposing is against what we do by default. If someone harasses you, you don't think about them with compassion. If someone steals, you punish them. You don't think about how to fix them.\n\nWell, my question is, why not? take the extreme case aside. If you are threatened by an imminent\ndanger, sure do whatever you find best. But that aside, when was the last time that you treated\nsomeone who was doing something &quot;wrong in your opinion&quot; with such a mindset?\n70 years ago, we were about to bring about WW2. And do you really think we have gotten better over the last 70 years, as species, with a higher level of consciousness, or are we the same, except we don't go to wars anymore because we have too much at stake?",
		"tags": [ "note"]
},

{
		"title": "An Open Letter to Javad Zarif",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/an-open-letter-to-javad-zarif/",
		"content": "I wrote comment in Iran's contemporary Minister of Foreign Affairs, Javad\nZarif's Youtube video on Iranian new year.\n\nThe gist of this man's message: &quot;accusing the west sanctions causing damage to Iranian healthcare system&quot;. This is just wrong. Don't get me wrong, me and my family suffer from the same, but let us at least be honest about it. For once in this regime's history, don't be be delusional. Stop blaming other countries and take responsibility.\nI wonder,\n\nWhen it comes to your Friday prayers and nationalist speeches, you do know very well how to shout &quot;America cannot do anything&quot; (ÿ¢ŸÖÿ±€å⁄©ÿß Ÿá€å⁄Ü ÿ∫ŸÑÿ∑€å ŸÜŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ®⁄©ŸÜÿØ) with confidence, yet now in times of need, you are saying that it is their fault? That it it because of their sanctions that out healthcare system is broken? That it is not because of our poor economy and infrastructure?\nWhat is this whole fight over in the first place? Nuclear energy? At least a part of it seems to be related. Okay, fair enough. Please answer, with dignity: How many lives has our &quot;holy&quot; nuclear plan saved so far? How many hungry people have been fed because of it? How many jobs have been created? How many people have been made happy? Now answer the following: How many people have experienced poverty because of it? How many businesses have been destroyed because of sanctions? How many families are torn apart because of poverty?\n\nI have tried to keep this comment polite and rational so far. I will finish with a more informal\ntone though:\nYou are a smart man. Perhaps among the only Iranian politicians in whom there is a spark of realism. Pull your head out of your ass, stop being delusional, stop lying, and start fixing something, before more harm as been done to this nation, who's lonelier than ever.",
		"tags": [ "note"]
},

{
		"title": "An Open Letter to Panic Buyers",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/an-open-letter-to-panic-buyers/",
		"content": "I wrote and twitted this in the midst of the first wave of the Covid-19 outbreak in 2020.\n\nDear Panic Buyer,\nHere is something to think about.\nSay there are 100 pieces of bread in the country and 100 people, and each person needs 1 on average. The country on the other hand, has the capacity to make 200 pieces if needed. If ,say, a handful of people among a population of 100 start stockpiling 4 times their needs in their house, this will be:\n\npointless, as there is enough supply for anyone anyhow.\nnonetheless, harmless.\n\nIf ,on the other hand, 1/2 of the population of a 100 start stockpiling 4 times more than their\nneeds, then we end up in this situation where the total demand (250) exceeds the total capacity of the country (200), for no good reason. The is problematic because it is not a real problem. It is\ncreated merely because of our excessive needs in the first place.\nOf course, a virus spread might actually lead to a real shortage of some supplies (i.e. where the\nexample country above can produce 80 or less) as well. But we are not there yet. And in the path of getting there, we will inevitably reach the above situation as well. Hence, the first phase of any real shortage, if that is what you are preparing for by buying, is cause by ourselves, not any virus.\nThat being said, also note that if the situation becomes so severe that even developed countries\nfail to provide food and basic needs, we'd probably have much bigger problem than food (electricity, sewage, hygiene, lack of healthcare etc.). Without food, we can technically survive for a fairly long time, weeks if needed.",
		"tags": [ "note"]
},

{
		"title": "Gallery-Raw",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/gallery-raw/",
		"content": "hidden raw gallery page to upload the resources/images relevant in the public one!",
		"tags": [ "note"]
},

{
		"title": "Gallery",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/gallery/",
		"content": ".grid {\n\nborder: 1px solid #ddd;\n\ncolumn-count: 4;\n\ncolumn-gap: 1rem;\n\npadding: 1rem;\n\n}\n\n@media (max-width: 1200px) {\n\n.grid {\n\ncolumn-count: 3;\n\n}\n\n}\n\n@media (max-width: 800px) {\n\n.grid {\n\ncolumn-count: 2;\n\n}\n\n}\n\n@media (max-width: 400px) {\n\n.grid {\n\ncolumn-count: 1;\n\n}\n\n}\n\n/* Only target images that come after #start within .grid */\n\n.grid img {\n\nwidth: 100%;\n\nheight: auto;\n\nmargin-bottom: 1rem;\n\ndisplay: block;\n\ncursor: pointer;\n\ntransition: opacity 0.3s ease;\n\n}\n\n.grid img:hover {\n\nopacity: 0.9;\n\n}\n\n/* Modal styles */\n\n.modal {\n\ndisplay: none;\n\nposition: fixed;\n\ntop: 0;\n\nleft: 0;\n\nright: 0;\n\nbottom: 0;\n\nbackground: rgba(0, 0, 0, 0.9);\n\nz-index: 1000;\n\npadding: 2rem;\n\nbox-sizing: border-box;\n\n}\n\n.modal.active {\n\ndisplay: flex;\n\njustify-content: center;\n\nalign-items: center;\n\n}\n\n.modal img {\n\nmax-width: 90%;\n\nmax-height: 90vh;\n\nobject-fit: contain;\n\n}\n\n.close-button {\n\nposition: absolute;\n\ntop: 1rem;\n\nright: 1rem;\n\nbackground: white;\n\nborder: none;\n\nwidth: 2rem;\n\nheight: 2rem;\n\nborder-radius: 50%;\n\ncursor: pointer;\n\ndisplay: flex;\n\nalign-items: center;\n\njustify-content: center;\n\nfont-size: 1.2rem;\n\nfont-weight: bold;\n\n}\n\n.close-button:hover {\n\nbackground: #eee;\n\n}\n\n// Create modal elements\n\nconst modal = document.createElement('div');\n\nmodal.className = 'modal';\n\nconst modalImg = document.createElement('img');\n\nconst closeButton = document.createElement('button');\n\ncloseButton.className = 'close-button';\n\ncloseButton.innerHTML = '√ó';\n\nmodal.appendChild(modalImg);\n\nmodal.appendChild(closeButton);\n\ndocument.body.appendChild(modal);\n\n// Add click handlers only to gallery images after #start\n\ndocument.querySelectorAll('.grid img').forEach(img => {\n\nimg.addEventListener('click', () => {\n\nmodalImg.src = img.src;\n\nmodal.classList.add('active');\n\n});\n\n});\n\n// Close modal when clicking close button or outside the image\n\ncloseButton.addEventListener('click', () => {\n\nmodal.classList.remove('active');\n\n});\n\nmodal.addEventListener('click', (e) => {\n\nif (e.target === modal) {\n\nmodal.classList.remove('active');\n\n}\n\n});\n\n// Close modal with escape key\n\ndocument.addEventListener('keydown', (e) => {\n\nif (e.key === 'Escape' && modal.classList.contains('active')) {\n\nmodal.classList.remove('active');\n\n}\n\n});",
		"tags": ["ddd", "start", "eee", "note"]
},

{
		"title": "Meta Cognition Framework",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/meta-cognition-framework/",
		"content": "MIA -- Metacognitive Introspective Awareness -- is the ability to be aware of the state and activity of the mind continuously. That is, the awareness of the mind as the mind carries on with doing something, e.g. watching the breath\n\nThis is a favorite concept from The Mind Illuminated, one of my favorite mindfulness books. In other words, watching the mind as the mind watches the breath.\nDoing this over and over again, I have noticed an interesting framework to categorize your thoughts and mind-wanderings while meditating, or even in day to day life. We assign 3 properties to each thought that mindlessly pops up:\n\nTime: is it about the past, the future, or present?\nFeeling: Is it a feeling of aversion or craving for something?\nSubject: Is it about you, or the outer world.\n\nBased on this, one could build a 3 dimensional space for thoughts, where you have.\n\nI was expecting to write this bit for myself with a conclusion to assert that a peaceful state of mind is one that is always in the center of this chart, but I am less sure about that and leave that open. Nonetheless the framework has been very useful to me in developing further MIA.",
		"tags": [ "note"]
},

{
		"title": "My Thoughts On Iran's Political Situation in 2022",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/my-thoughts-on-iran-s-political-situation-in-2022/",
		"content": "[!info] I started writing this on the 27th of September 2022 and ever since the situation, and my opinion has slightly changed.\n\nWhat I intend to do here\nBreezing over Iran's social media and news these days, the environment is filled with emotions. Opinions are flying by, with everyone telling what others ought to have done or said. I understand why that could be, but I want to insist that I am not here to convince anyone of anything. I am merely writing down some opinions I hold for the sake of posterity.\nMoreover, I entirely agree that some of my opinions might not be exactly on-par with what fellow Iranians think, and I want to emphasize why I think that's the case before going further.\nThe first reason for my unorthodox opinions is perhaps my background and current living situation, which I cover in more detail in the next section.\nSecondly, we are highly social animals, and the desire to be part of a tribe is deeply rooted in us. Similarly, the feeling of being ostracized is extremely discomforting. Ever since the emergence of this movement, I have found myself facing a dilemma:\n\nShould I also indulge in being active online, be loud and bold, be part of the movement, and feel part of the tribe.\nOr, keep my head above water, and only do something if I wholly think of it as being beneficial.\n\nTruth is, every time I came close to choosing option number 1, I'd realize that I am not doing it because I really think it is useful. I am, instead, doing it either out of the desire to be &quot;part of the movement&quot;, or &quot;fear of being judged if I don't&quot;, neither of which is a correct reason to do something.\n\nNot to be mistaken, I have tried to play more role in helping the liberation of Iran by increasing awareness about it, mostly in person, within the circle of my friends, and have participated and aided local protests where I live. I do not face the same dilemma as above while doing such acts.\n\nThis situation has led me and my opinions on the matter to be somewhat disconnected from the mainstream narrative, which contributes to my opinion being perhaps unacceptable to the majority.\nThirdly, to put it shortly, I strive to not act emotionally under any circumstance, and you should be able to see traces of this in most of my comments. I strongly think we, both individually and collectively, come to better conclusions if we think less emotional and more rational. If you think otherwise, we can agree to disagree on many things.\nWhere I am coming from\nFirst, let's establish who I am and where I am coming from. I am raised in a fairly open-minded middle/upper class family in Iran. I was never highly exposed to Iran's brainwashing propaganda, Islam, or anything like that. Likewise, I never distinguished Iran's regime as a rightful one. That being said, I must also confess that I was never directly annoyed by this regime either. Even though my teenage years were the start of the decline of Iran, I was mostly capable of having a good life. This was in part due to my family's above-average financial situation (which was deteriorating at the time), and the fact that I studied compute engineering, I liked it, and put a lot of effort into it. Consequently, there were plenty of job opportunities for me as a student, earning at least some money. In some sense, while some of my friends were in a &quot;there's nothing to achieve in this country&quot; mentality back in e.g. 2015, I was happily swimming against the current. To some extent, I hold the same opinion today as well. In short, I am coming from a position of privilege.\nNext, looking at where I am now, writing this. I have been away from Iran for almost 5 years now, and I am even more independent of it. Yes, Iran's regime has gotten ever so more brutal over the years, but I have also moved away further, and I am objectively less affected by it.\n\nAs a side note, the PS flight was taken down two days after I flew out of Iran in early 2020. Yes, that was a bit close, but I still happily consider myself very independent of Iran's politics.\n\nLastly, I have, over the years, never really benefited particularly from Iran's regime, or never really grown fond of it in any way either. I did believe in the reformist movement of Iran a decade ago (and perhaps even today consider it the better choice between &quot;bad and worse&quot;), but all in all I don't see have any reason to defend Iran's government and regime. For the remainder of this writing, if I criticize the opposition of Iran, please be aware that I do not mean to imply any sort of approval for the existing order.\nAll in all, I consider myself to be in a spot where I can cast an unbiased opinion on the situation of Iran, which can be unique. To recap, I am neither benefiting from nor directly harmed the current regime in Iran. I follow the news, but not enough such that I can't keep both feet on the ground. I entirely agree with the reasons that the people on the street protesting have, but I don't share the emotions with them as much. Whether an opinion coming from such a position like mine is worthy of anything or not, is up to you.\nThe Good\nThe uprising in Iran is the consequences of what the current regime has done over the last few decades. It is not the first of its kind either, and there has been periodic events such as this one ever since 2009's green movement, if not earlier. The living conditions in Iran have declines rapidly over the years, the international presence has gotten worse and worse. All of this justifies a &quot;change&quot;, and is not anyone's wish to see it continue.\nAlso, Iran is being ruled by people with radical religious beliefs, and putting a stop to that is something that I hope to see both in Iran and globally. I fully hold the right for any religious person to practice what they believe, but imposing it forcefully on others is just none-sense. I insist on the forceful part, because Iran is evidently no longer majority Muslim.\nAdmittedly, I don't want to talk about the &quot;Good&quot; part much further, because it is self-evident. It is the uncontroversial part. Of course, I wish Iran would suddenly change and become a better and free and prosperous country. Of course, I wish women and men would both have equal rights and freedom. Of course, I agree that the current regime does not even show any sign of hope for the aforementioned. And a protests/revolution is seen as a &quot;light at the end of the tunnel&quot;.\nThe Bad\nWhatever you want to do, you will do it better if you have a calm mind.\nI sometimes see a narrative that is proudly and boldly spreading &quot;look how miserable I am because of this&quot;, and is harshly criticizing anyone who dares to say &quot;yeah, times are hard, but I am doing okay&quot;.\nIt is entirely understandable that certain people might have a hard(er) time coping with the ongoing events, and sharing it online is perhaps helpful[1]. Nonetheless, I see two important facts here:\n\nWe all deal with different situations in our own way. If someone is dealing with it with less misery, it does not have much to say about their opinion and stance on the matter.\nIf we want to optimize for effectiveness, almost without a doubt, a balanced mind is more effective at making any sort of decision than an unstable one. For example, if you want to write a tweet and post it, you would probably come up with a better, more catchy, more viral tweet if you are calm.\n\nSo, while times are hard, I think we should embrace wellbeing more, and support each other to all feel better, less affected, and less unhappy about the situation, while combating it. Then, we would both feel better as individuals, and I hope we can come to a better outcome collectively.\nThere is nothing exciting about the violence involved.\n\nTheo: (talking about Orcs) How many have you killed?\nGaladriel: Many.\nTheo: Good.\nGaladriel: I would not use such words.\nTheo: Why not?\nGaladriel: It darkens the heart to call dark deeds ‚Äúgood.‚Äù It gives place for evil to thrive inside us. Every war is fought both without and within.\nOf that, every soldier must be mindful.\nEven I. Even you.\n\nFrom the TV show Rings of Power\n\nI was recently told by a very close acquaintance of mine: &quot;Yeah, if you feel down, I can send you this video where the people beat the shit out of that other guy (the other guy being a &quot;basiji&quot;), see it, and you feel better&quot;.\nWhen I heard this, I only nodded and smiled, but I really find it disturbing. This is fucked up. My friend should not enjoy seeing others being beaten up so much, regardless who is beating up whom. Yes, that friend of mine can say &quot;Look, the situation has traumatized me so much that ...&quot; but I honestly think this is an excuse. Wishing to invoke violence on others is nothing to feel happy about, and if you are in a spot where you do feel happy about it, you might have indulged too much into emotional sentiments such that it has blinded your thinking and (more importantly) morality altogether.\nI am aware that the police in Iran does deploy force frequently, and it makes perfect sense for people to use force for defense. I am sorry to say this, but the harsh, sad, cold reality is that anything beyond defense makes the attacker be of the same nature as the person being attacked.\nMoreover, while I think this is not a strong argument anymore, every instance of violence from the people towards the government will be used as propaganda and and reason for more suppression and violence. It is a snowball that will only get bigger So, I think it is wise to use the minimum amount of violence, especially as the one claiming to be on the morally correct side.\nLastly, I think this will set a very grim precedence for what the Iran's 2022 &quot;revolutionists&quot; are willing to do. Do they have higher standards regarding maintaining peace? or are they the other side of the same coin?\n\nWe only seem to respond in kind, an eye for an eye only leaves us blind.\n\nMob Mentality. Radical Polarization\nI am seeing a mirror of something that you can also see in the western world, one that I respectfully disagree with, in Iran as well. Namely, a mob mentality of loud people on social media, roaming around telling others what they should say, think, post, and hashtag, and so on. This, in effect, creates a sense of fear, where individuals feel the fear of being left out if they don't join the mob, i.e. if they also don't share the same hashtag, or buy into the same opinion. This approach is being weaponized by both the right and left-wing political movements of modern western nations as well.\n\nAnd this exacerbates the personal dilemma I mentioned in the first section.\n\nIn my opinion, this is not a good approach, regardless of which ideology you are propagating. Mainly, this approach forces people to take sides based on fear and reactions, not based on thoughtful assessment. In the long term, this creates more schisms, radical mindsets not coping with one another, and deteriorates the movement, in my opinion.\nFor example, the current sentiment in Iran is a unified movement against the current regime, and anyone, especially if they are slightly famous, have to take sides now, and if they remain silent, they are ostracized for it. For people who have very large audiences, this is arguable, yet still incorrect (in my opinion). But seeing this mentality leak toward normal people, expecting them to also silently follow the mob is extremely worrying.\nAbstention is seemingly not acceptable. There is no room for &quot;this is a complicated situation and I have to think about it&quot;. There is no &quot;I have a mixed background and I am confused by all of this&quot;. You are either with US NOW, or you are one of THEM. This is a terrible mindset.\nFinishing this with quoting my humble self in a friendly discussion I had with my brother:\n\n..but if we imagine ourself in a position where we can dictate to other what to do, what to say and what to think, we are not much better than that which we are fighting against.\n\nConsequences matter. Things could get worse.\n&quot;anything is better than this&quot; is how most people of Iran think of the existing order. Similarly, I hear &quot;we should first focus on abolishing the existing order and then think about what could replace it&quot;.\nwhile I do see where it comes from, I think it is worrying and slightly short-sighted. I might be a conservative, risk averting person here, I but I cannot start a massive, fundamental process of &quot;change&quot; without having a plan. Imagine you want to refurbish a house, and you just start a hammer and randomly tear down walls, hoping that you eventually get the right outcome. It might work, but it is quite likely that it might not, and in that case, we might be left with nothing. It is an approach, but we should be aware that it is a risky one.\nInterestingly, I recently learned (through the amazing book Persepolis) how the 57 revolution of Iran was hijacked by one of the forces behind it, namely the Shia clerics, and for many people it did not have the outcome that they intended. With the short-sightedness thinking of the existing movement, I see the possibility of something like this happening again. Interestingly, I do recall people arguing, in tweets, that the current revolution of Iran being leaderless and short-sighted is actually a good thing, but I have not seen a convincing debate about it.\nThe Ugly\nFailure to fix Iran in a peaceful way is a both way failure, not just on them.\nIf this revolution succeeds, it will be the win for a group of people (those who supported it), a lose for those who wanted to stop it, and a failure for all of us as a whole, because we failed to put our differences aside and collaborate in a peaceful way.\nYes, the side that currently has the power is more responsible, but this is absolutely a two-way situation. We should remember our failure just as we should remember our victories, and hopefully learn from them.\nChange the game, not the team\nI am worried that, if this revolution succeeds, we are removing a radical, oppressive, intolerant islamic regime, and replace it with a radical, oppressive, intolerant normal regime. If we are to avoid this, I strongly think that we should think differently. We should not take the same set of rules, and change verbs and nouns in them. We should change the rule itself. For if the rule is flawed, it is only a matter of time until you are again back on the side of it where you don't approve of it.\nA simple example of this is being oppressive. The current regime is oppressive towards us. If we only change the subject, the nouns in this flawed rule, we are only creating a temporary bubble, where, if we are lucky, for some years, we get to to be oppressive towards others. But this is not changing anything. This is the other side of the same coin. The fundamental flaw here is &quot;oppressiveness is allowed and acceptable&quot;, not &quot;we are being oppressed&quot;. There is a MASSIVE difference between the two. In the former, you are eradicating a bad rule, in the second one, you only wish to not be the subject of it.\nThe meta-problem at hand is that we are constantly failing to come to a consensus as a society. This is a problem that exist in Iran today, and trust me, it exist in most developed countries as well. It is only the subject and severity that is different between the two. If we play by the same rule, we are not fixing these meta-problems. People will change, and will fail to agree to one another on other topics as well. The consequences might not be severe as the total disaster that the Islamic Republic as left behind, but the issue will nonetheless be there.\nExistential doubt: What justifies one opinion to be right over the other?\nA brainwashed woman in Iran is willing to live a hard economic life, not taste any freedom, and she wishes for the current regime to survive, so that she can live happily in her bubble. If the regime goes away, should would certainly feel miserable.\nA teenage girl, living with dreams of one day living in a free, pro-west Iran, where she can have equal rights as men, walk freely in the streets without hijab, thinks very much otherwise, and sees her life as doomed for as long as the islamic state remains in Iran.\nWhich of these people has more justified right to enforce her desire to be happy, and cause the suffering of the other one?I sometimes don't know, and I really think it is more nuanced than what I originally thought.\nI originally thought that the young girls is simply the more justified one, because it so appeared to be. Or, because I share the same desire with her and don't share the same wish with the brainwashed pro-islam woman. This is my intuitive, emotional opinion.\nBut is that enough?\nA bit more objectively, I already answered my practical answer to this dilemma earlier in this text, that other than having more in common, I would chose to team with the young woman because I think we should live in a society where the rules (which would inevitably at times cause some people to be happier, and some to be miserable in return) to be at least based facts and reality, rather than religious and superstition. This is my rational opinion.\nSo, with all my heart and brain, I am with the teenage Iranian girl here.\nBut I think it is crucially important remind ourselves that in the mind of the brainwashed woman, what the young teenage girl is doing, is probably as bad as what the teenage girl thinks the islamic state is doing to her.\nThis does not change anything about the state of Iran being an absolute nightmare. But at least to me, it has yielded a new perspective on how I look at others, specially those who don't share the same opinion as me.\nFinal Thoughts: Some Hard Questions\nI will finish my first draft with some questions that I think are thought provoking.\nAssuming the revolution succeeds. Think about the following:\n\nWhat will our history books say? How will we depict the Islamic state that once ruled Iran. Will we be any different toward them, than how they depicted the Pahlavi kingdom?\nHow many opinions and thoughts are going to be indoctrinated and become unquestionable in the post-revolution Iran?\nHow many people will be executed?\n\nAlthough highly questionable as well, as many studies link social media to more depression and isolation. ‚Ü©Ô∏é",
		"tags": [ "note"]
},

{
		"title": "Playlists",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/playlist/",
		"content": "A subset of my Spotify playlists that I am fond of. This page is not organized by language. Some playlists are English, some Persian, some mixed.\n\nMain\nMain two playlist for day to day and work. Both electronic and techno, Teshno being more mellow, and Tekhno being more upbeat.\n\nMisc\n\nK-Hole\nA number of playlists dedicated to journeys induced by Ketamine.\n\nVitamin K is the master playlist I used when partying some old friends and K.\nK-Hole lists are 40-60 minute playlists, dedicated to one theme, having an ideal duration for 1 ketamine intake.\n\nFor Psychedelic Trips\n\nAcid Playlist\nThe following 4 are just some songs categorized by feelings/vibes.",
		"tags": [ "note"]
},

{
		"title": "Rumi",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/rumi/",
		"content": "Love, in Rumi‚Äôs vision, is when the ego or carnal self (nafs) is naught; and such love is realized when the heart is open and the mind is awakened to the reality of life beyond the fictional ego.\n\nRumi, Jalaluddin. Rumi: The Art of Loving (p. 24). Rumi Poetry Club. Kindle Edition.\n\nOn The Pain and Joy of Longing\nI am madly in love with you. What good is advice and preaching?\nI have drunk the killing water of love. What good is a little sugar?\nThey say, ‚ÄúPut chains on his feet.‚Äù\nThe madness is in my heart. What use is the chain on my feet?\ndar esh‚Äôƒ£-e to‚Äôam, nasiihat o pand che suud?\nzah‚Äôr√¢b cheshide‚Äôam, mar√¢ ƒ£and che suud?\nguuyand mar√¢ ke: band bar p√¢sh nehid div√¢ne del ast,\np√¢m bar band che suud?\nYou‚Äôre gone, and in my longing I shed tears of blood.\nThis ever-increasing grief of you makes me cry more.\nNo, I‚Äôm not saying it right! When you left, my eyes went after you.\nSince my eyes have gone with you, how can I cry?\nrafti vaz raftan-e to, man khuun migeryam\nvaz ghosse-ye afzuun-e to, afzuun migeryam\nnay, khod cho to rafti, pe-ye to diide beraft\nchon diide beraft, baa‚Äôd az √¢n chun geryam?\nThe Search\nWithin your living being, there is a spirit. Search for it!\nIn the mountain of your body, there is a jewel. Search for it!\nO, wandering Sufi! If you are looking for it, don‚Äôt seek it outside; it is to be found within you.\ndar j√¢n-e to j√¢niist, bejuu √¢n j√¢n\nr√¢ dar kuuh-e to, dorriist, bejuu √¢n k√¢n r√¢\nSufi-ye ravande, gar to √¢n mi‚Äôjuuyii\nbiiruun to majuu, ze khod bejuu to √¢n r√¢\nO pious seekers who are wandering in the world:\nWhy are you perplexed by a mental idol?\nWhat you are seeking the whole world for,\nseek within yourself. You are already that.\ney ahl-e saf√¢ ke dar jah√¢n gard√¢niid\naz bahr-e boti cher√¢ chonin heyr√¢niid?\nuu r√¢ ke shom√¢ dar-in jah√¢n juuy√¢niid\ndar khod cho be-juuyiid; shoma khod √¢niid\nIn the streets of your own mind, what are you seeking?\nWhy are you washing your eyes with tears of blood?\nFrom head to toe, you are possessed by Truth.\nYet, you remain so ignorant of yourself: What else are you seeking?\ndar ku-ye khy√¢l-e khod che mi‚Äôpuuyii to?\nvin diide be khuun-e del, che mi‚Äôshuuyii to?\naz farg-e sarat t√¢ be ƒ£adam, haƒ£ƒ£ d√¢rad\ney bi‚Äôkhabar az khiish, che mi‚Äôjuuyii to?\nYou have severed our relationship, but I do not despair.\nYou have chosen another lover, but I do not despair.\nAs long as I live, your grief will be my food.\nThere is much hope even in hopelessness; I do not even despair.\nniyam, garche ze man bobridii\ny√¢ bar sar-e man y√¢r-e degar\nt√¢ j√¢n d√¢ram, gham-e to kh√¢ham khordan\nbesiy√¢r omiid hast dar nomiidii\nIf your quest is the soul‚Äôs home, you are that soul.\nIf your search is for a loaf of bread, you are that bread.\nIf you know this secret, you know the secret:\nThat you are seeking, you are that.\ngar dar talab-e manzel-e j√¢ni, j√¢nii\ngar dar talab-e loƒ£‚Äôme-ye n√¢ni, n√¢nii\nin nokte-ye ramz agar bed√¢ni, d√¢nii:\nhar chiiz ke dar jostan-e √¢ni, √¢nii\nWho Am I?\nI am not concerned with to be or not to be.\nI am detached from them both. Yet, that is not bravery.\nThe wonders in my heart don‚Äôt drive me crazy.\nThis is bravery and the real madness!\nb√¢ hasti o niisti-yam, bi‚Äôg√¢negist\nvaz har do boridanam, na\ngar man ze aj√¢yebi ke dar del d√¢ram\ndiv√¢ne nemishavam, ze div√¢negist\nWhen your chest is washed clean from the ego,\nyou will see your true self and your first love.\nYou cannot see your own face without a mirror.\nLook at the Beloved; He is your mirror.\nchon p√¢k shod ze khodi-ye to, siine-ye to khod-bin gardi, ze y√¢r-e diiriine-ye to\nbi √¢yiine ruuye khiish natv√¢ni diid\ndar y√¢r negar, ke uust √¢yiine-ye to\nThe Beloved's Face\nAs long as the face of that enviable angel is imprinted in my heart,\nin the whole world, who is as joyous in heart as I?\nO God, to live this happy life is all I know.\nI keep hearing about sorrow; what it is, I don‚Äôt know.\nt√¢ dar del-e man suurat-e √¢n rashk pariist\ndelsh√¢d cho man, dar in hame √¢lam kiist?\nvallah ke be-joz sh√¢d nemid√¢nam ziist\ngham mishenavam, vali nemid√¢nam chiist\nDie To Yourself\nIf you want your soul to be nourished and fulfilled;\ndon‚Äôt go to sleep. Let the loving fire of the Beloved burn you;\ndon‚Äôt go to sleep. For hundreds of nights you have slept; you know the outcome.\nDo yourself a Divine favor: Tonight until dawn don‚Äôt go to sleep.\ngar miikh√¢hi baƒ£√¢ vo piruuz,\naz √¢tash-e eshƒ£-e duust, misuuz,\nsad shab khofti o h√¢sel-e √¢n diidii az bahr-e khod√¢\nemshab t√¢ ruuz makhosp\nThe secret of madness is the wellspring of wisdom.\nLove‚Äôs madman is also a man of refined knowledge.\nOne who becomes the heart‚Äôs friend through the path of pain,\nbecomes a stranger to himself in a thousand ways.\nsar‚Äôm√¢y-ye aƒ£l, serre diiv√¢negist\ndiiv√¢ne-ye eshƒ£, mard-e farz√¢negist\n√¢n kas ke shod ashen√¢-ye del dar rah-e dard\nba khiishtanash hez√¢r biiganegist\nSo full of yourself, you cannot taste drunkenness;\nattached to your Flesh, you cannot be devoted to the Soul.\nIn the path of love, you will not reach the real being\nuntil you let go of yourself like water and fire.\nt√¢ hosh‚Äôy√¢ri, be taa‚Äôme masti\nt√¢ tan nadahi, be j√¢n parasti\nt√¢ dar rah-e eshƒ£-e duust chon √¢tash o √¢b\naz khod nashavi niist, be hasti naresi\nArt of Living\nWe are lovers of love. Submission to a creed is something else.\nWe are poor ants, collecting love.\nSolomon‚Äôs kingly life is something else.\nIn our longing, we have pale faces and torn hearts to offer. If you desire a fashion market, go somewhere else.\nm√¢ asheƒ£-e eshƒ£iim o mosalm√¢n degar ast\nm√¢ muur-e za‚Äôiifiim o Soleym√¢n degar ast\naz m√¢ rokh-e zard o jegar-e p√¢re talab\nb√¢z√¢rche-ye ƒ£asab foruush√¢n degar ast",
		"tags": [ "note"]
},

{
		"title": "Sa'di",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/sadi/",
		"content": "banƒ´-ƒÅdam a øzƒÅy-e yek digarand\nkeh dar ƒÅfarƒ´nesh 'zeh yek goharand\ncho  øozvƒ´ be-dard ƒÅvarad r≈´zgƒÅr\ndegar  øozvhƒÅ rƒÅ namƒÅnad qarƒÅr\nto k'az me·∏•nat-e dƒ´garƒÅn bƒ´-ghamƒ´\nnashƒÅyad keh nƒÅmat nahand ƒÅdamƒ´\nHuman Beings are members of a whole\nIn creation of one essence and soul\nIf one member is inflicted with pain\nOther members uneasy will remain\nIf you have no sympathy for human pain\nThe name of human you can not pertain\n\nBani Adam - Wikipedia",
		"tags": [ "note"]
},

{
		"title": "The Price of Change",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/the-price-of-change/",
		"content": "Whether you want to change or not is a delicate question, and depending on the circumstances, and ultimately a decision that can be made, but one thing that has become clear to me over the years:\n\nChange always comes with a price, and that price is an old part of you that you have to let go.\n\nA dominant example, quitting bad habits and adopting new ones. When I quitted smoking cigarettes, I certainly had to let go of a big part of my personality and community. I had to adopt new habits. I had to learn to replace my desire for smoking with other ones. I mainly emphasized on sports (luckily runner's high is very real, and a very good sensation) and to some extent cooking and food. I learned to enjoy being healthy.\nLooking back, if I had only quitted smoking, and had not changed any other parameter in life, it would have not been possible.\nAnother example, a breakup. In my experience, I won't ever be able to move on from someone if I expect/seek to repeat the same experiences, the same inner jokes, and the same dynamics, with someone else. It frightens me, but I know that every time I get intimate with someone, I am letting go of a former side of myself, and developing a new one (assuming a monogamous context).\nConsequently, I don't believe in a permanent &quot;love language&quot;. I think we have a baseline of preferences, which you can call a love language, but more importantly a &quot;love dialect&quot; that is unique to any partner we get initiate with throughout our lives.\nAnd the (sad, but true) twist in all of the above is that, for some of us, possibly those with more of an anxious attachment style, myself included, it is increasingly difficult to let go of things that are dear to us. Acknowledging that I am changing is a double edge sword because as much as experiencing a new version of myself is exciting, letting go of that part of that older part is deeply frightening.",
		"tags": [ "note"]
},

{
		"title": "Uneducated, Unaffiliated, Disinterested",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/personal/uneducated-unaffiliated-disinterested/",
		"content": "The setup is simple: casting an opinion on the matter.\nThere are 3 parameters to evaluate between the person and the matter:\n\nPersonal affiliation: either having some degree of emotional attachment to the matter beyond baseline empathy that most people would have.\nInterest: To be economically attached or not, i.e. skin in the game.\nEducation: having a very high degree of proficiency such that they know the matter at hand almost at full.\n\nAnd the simple conclusion can be that all 3 parameters should be maximal to achieve a good opinion. But is that always the case? some counter examples that I have encountered in my life:\n\nEducation: In many technical conversations between those that are experts in a sub-system, it is super useful to have the opinion of someone who has some degree of high level information, but is not an expert and therefore can provide an out-of-the-box opinion. I have been on both sides of this myself.\nInterest and Affiliation: I am from Iran, and consider myself educated about conditions of living there, but because of living abroad for many years, less so emotionally and economically attached. In other words, I am in a position of privilege compared to those that actually still live in Iran. and I have found myself to sometimes have differing opinions about Iran, and think that this position of privilege can actually be useful (see <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/my-thoughts-on-iran-s-political-situation-in-2022/\">My Thoughts On Iran's Political Situation in 2022</a>).\n\nIn short, what I would conclude is that in a given situation, it is useful to incorporate opinions that are either (somewhat) uneducated, unaffiliated and uninterested.",
		"tags": [ "note"]
},

{
		"title": "Posts Index",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/posts-index/",
		"content": "Tech\n\nFile\nDate\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/sharded-and-non-sharded-tps-in-blockchains/\">Sharded and Non-Sharded TPS in Blockchains</a>\nFeb 11 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-sdk-2024/\">Polkadot SDK 2024 Roundup</a>\nNov 22 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/multichain-api/\">Multi-Chain SDK Vision</a>\nSep 04 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/on-documenting-polkadot-sdk/\">On Documenting polkadot-sdk</a>\nJul 10 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/\">Demystifying JAM</a>\nMay 02 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-s-build-horizon/\">Polkadot's Build Horizon</a>\nMar 16 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/thoughts-blockchain-and-blockspace-scalability/\">Thoughts Blockchain and Blockspace Scalability</a>\nFeb 27 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/for-those-who-don-t-want-rust-analyzer-one-regex-to-rule-them-all/\">For Those Who Don't Want rust-analyzer - One Regex to rule them all</a>\nAug 31 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/the-10x-developer-myth-all-about-keyboard/\">The 10x Developer Myth: All About Keyboard</a>\nAug 31 2023\n\nPersonal\n\nFile\nDate\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/sadi/\">Sa'di</a>\nJul 26 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/uneducated-unaffiliated-disinterested/\">Uneducated, Unaffiliated, Disinterested</a>\nMar 30 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/gallery/\">Gallery</a>\nMar 30 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/meta-cognition-framework/\">Meta Cognition Framework</a>\nMar 24 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/the-price-of-change/\">The Price of Change</a>\nMar 23 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/playlist/\">Playlists</a>\nMar 16 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/rumi/\">Rumi</a>\nMar 10 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/my-thoughts-on-iran-s-political-situation-in-2022/\">My Thoughts On Iran's Political Situation in 2022</a>\nDec 27 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/amsterdam-bunker-talks-experience-1/\">Amsterdam BunkerTalks Experience 1</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/an-open-letter-to-panic-buyers/\">An Open Letter to Panic Buyers</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/personal/an-open-letter-to-javad-zarif/\">An Open Letter to Javad Zarif</a>\nAug 28 2023",
		"tags": [ "note"]
},

{
		"title": "Runtime Function Onboarding 2024",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/runtime-function-onboarding-2024/",
		"content": "[!info]- Collaboration\nIf you would like to collaborate on this article and/or leave feedback, consider opening a Pull Request here.\n\nüëãüèª Intro: Welcome to The Runtime Function\nWelcome to Parity, welcome to the Runtime Function, arguably one of the most important teams within Parity and the Polkadot Ecosystem.\nWhat do we do? We build everything that is needed for the Runtimes of the Polkadot ecosystem to exist. Remember, the runtime is where the application logic of all of our blockchains live. The runtime function is at the moment divided into 3 teams:\n\n(Substrate[1] +) FRAME + XCM: Build and maintain the (mostly) un-opinionated frameworks/SDKs that allows us to build blockchains, runtimes and enable communication between them. All of the aforementioned are part of polkadot-sdk.\nPolkadot System Runtimes: Then, we build applications with Substrate, FRAME and XCM. This includes: The runtime of the Polkadot and Kusama relay-chain, plus all system-chains. The community of Polkadot builds Parachains with all the same tools.\nBridges: Given its proximity to FRAME and XCM, the core developers working on trust-less bridges reside in the Runtime Function as well.\n\n[!info]- Note on Naming\nIn a lot of our communication, we refer to Relay Chain as RC, and System Chain as SC. Moreover, a lot of the system chains are called ‚ÄúSomethingHub‚Äù, which is often abbreviated as *H. For example, AssetHub is referred to as AH.\n\nüíä The Reality of What We Do\nWorking in the above implies two very important self-evident truths about the type of work we do:\n\nWe fly low:* The work we do is meant to interact with value-bearing, mission critical systems that are meant to survive the test of time. This implies:\n\nEmphasis on testing.\nDemand and provide vigilant code review.\nNonetheless, mistakes happen, and it is okay. What is not okay is to repeat a mistake. We maintain a categorical zero-blame mentality, learn from mistakes, make sure it cannot happen again, write a public post mortem, and move on.\n\nWe fly close to end-users/developers*: Most of what we write affects our two major stakeholders: developers (parachains, UIs, and more), and blockchain users.\n\nAlways think about: user-facing code, vs. non-user facing code.\nIs my feature well documented? can someone else use/understand it?\nIs my feature a breaking change?\n\nWe will repeatedly come back to these two points throughout this document.\n\n[!info]- An anecdote about breaking production code @kianenigma\nThe main downtime of Polkadot is partially because of my code. Many collaborated to fix the issue, and we learned countless lessons about how to test our code, eventually leading to the creation of try-runtime-* set of tools, just to name one.\n\nüìà¬†Function Portfolio\nLet‚Äôs take a moment and introduce you to a non-exhaustive list of great things that function is currently working on, in the words of the maintainers themselves:\n\n[!tldr]- Stability\nParity has a history of rug-pulling Polkadot builders with new technology one after the other üôà The Stability initiative is here to stop this. By introducing stable releases (New Release Process), a no-code Parachain node (Omni-node) and focusing generally more on improving existing features instead of adding new ones we are aiming for a smother experience for Polkadot builders.\nOliver, Liam and Kian\n\n[!tldr]- XCM v5\nXCMv5 aims to improve developer and user experience for all cross-chain interactions. Its main features are seamless fee integration, facilities for claiming trapped assets and helper instructions for easier cross-chain transfers. This is the latest evolution of the XCM standard via the open RFC process.\nCisco\n\n[!tldr]- Coretime Broker Pallet\nThis year Kusama and Polkadot transition away from the slot auction model to Agile Coretime. The Coretime Chain is a marketplace where NFTs representing various configurations of blockspace can be bought, manipulated and allocated. Coretime (bulk and on-demand) is now the only way to validate workloads on Polkadot. The broker pallet contains all the logic for the primary market for blockspace, upon which secondary markets can be built and is the main part of the coretime chain. The specification is contained within¬†RFC-1¬†and¬†RFC-5, and you can find out more in our¬†Coretime FAQs.\nDonal\n\n[!tldr]- People Chain\nThe people chain is the place where real world identities are brought onto the blockchain. In other parts of the system (and blockchain in general), a lot of emphasis is put on anonymity; you are an account that interacts with other accounts. The people chain is where you can showcase your real world identity by linking your Polkadot account with various off-chain accounts such as Twitter, Discord, GitHub, email and more.\nThis bridges a gap between on-chain and off-chain knowledge and allows users to introduce information from the outside world and securely use it for various on chain activities.\nGeorge\n\n[!tldr]- Multi-Block Staking\nDiscover Polkadot's innovative validator election method using¬†NPoS. Dive deeper into our efforts to¬†scale the number of stakers¬†nominating on Polkadot. Join us as we¬†migrate staking functionalities¬†from the relay chain to a system parachain.\nAnkan and Goncalo\n\nüì° Communication\nüìû Sync\n\nWeekly &quot;Runtime Function Hangout&quot; call.\n\nAgenda curated collectively in calendar invite. If you'd like to encourage others to show up, put your item there.\nCommunicate important decisions in the group chat for those who are not present.\nOptional in general. Join based on your workload, and the agenda.\n\n1-1 with your team lead.\n\n[!tip] Getting To Know Your Teammates\nInspired by what Oliver did when he joined in early 2022, I highly encourage you to setup 1-1 intro calls with all other RF members in the first week or two. Get to know them, what they work on and so on! It will help you settle-in, and give you opportunity to also ask any random questions you have about FRAME, XCM, Polkadot, Parity and so on!\n\nüìß Async\n\nParity forum Polkadot forum.\n\nPrefer accompanying Google Docs for discussions that will need lots of revision.\n\nGitHub\n\nBuild a system around notifications, you are expected to reply to your @mentions.\n\nElement\n\nEverything under Runtime Function space. Explore sub-spaces and rooms accordingly\n\n[!info]- The Runtime Function Element Space\nThis is an example of who the spaces and sub-spaces in our Element space looks like.\n\n[!tip]- More on Element\n\nPro tip: You can always group a number of chats from different spaces (or no space in particular) into a private space, if you'd like to group chats together and avoid the &quot;Other Rooms&quot; or &quot;Favorites&quot; to bloat.\nBe mindful of joining too many rooms, if it prevents you from keeping up with notifications that actually matter.\nConsider using alternative Matrix clients, if it fits you better.\nElement supports a very simple to set up RSS feed, which can be useful to keep up with things.\nCustom keyword notifications in Element/Matrix are very useful to keep you up to date with certain topics that you feel responsible for.\nMore in the devops wiki. Ask questions in Element/Devops Helpdesk if need be.\nDoc for our last round of element revamp.\n\nWhy do we use element to begin with?\n\nPrivacy-preserving, semi-redundant due to connectivity with other homeservers (so even if ours goes down, people on other homeservers can still interact with the channels they're in). Interoperable (with other chat protocols, due to bridges), customizable/programmable and control over our data.\nErin\n\nüò± Where/How-much to Write?\nA common question around async communication in chats is how &quot;loud&quot; you should be. For example, whether you should talk in big chats, as opposed to DM.\nWe are a fairly small company. Prefer sharing things in broad element groups where most people can see them, rather than small chats with a handful of people. As an example, we have vibrant chats such as:\n\nEngineering General\nFRAME Public\nXCM Public\npolkadot-sdk-docs\n\nThat are used for various discussion topics, requesting reviews and Q&amp;As, and using them is highly recommended.\n\n.. But what if I am too loud, what if I annoy someone, or ask a <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#dumb-questions\"> dumb question</a>?\n\nShort answer: It is not your problem.\nIn an async environment, it is much easier to be under-heard and under-share, than the opposite. Therefore, it is safer to optimize for over-sharing, and only adjust if necessary.\nIf you're over-sharing and are actively annoying anyone, it is their responsibly to give you that feedback, and you should adapt if the feedback is reasonable. But if you are silently under-sharing, it is much harder to identify it as an issue and recover from it. I suggest always preferring to share something where the most broad audience can see it, unless you conclude otherwise for some specific reason.\n\n[!example] Async Communication 101\n\nAdjust your workflow (as much as possible) such that you are NOT blocked by other's not replying to you immediately. Explore a reasonable degree of multi-tasking.\nBe concise and to-the-point in conveying your message. The &quot;no hello&quot; is a good example üòâ.\nPrefer sharing things where most poeple can see it.\nPrefer sharing things where it has the most longevity.\n\n(See <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#information-de-centralization-and-longevity\">Information (de)Centralization and Longevity</a>)\n\nü§™ Dumb Questions\nParity has an interesting attitude towards this. We have a room specifically called &quot;Parity Dumb Questions&quot;, to remind you that there is no such thing as a dumb question[2].\nLet's be honest: Web3 is a complicated space, for both engineers and non-engineers. Only a few are knowledgeable enough to have a high level understanding of everything. Most of us are new in this space. Moreover, this space (and Parity) move really fast. What you know today might need an update in 6 months.\nSo, in short: There are a million things to (re)learn, and asking those who know better than you is the wisest thing you can do. As the saying goes: &quot;The only dumb question is the one you don't ask&quot;.\nBut, there are a few notes that you should keep in mind about questions:\n\n[!info] Asking Questions 101\n\nFirst, while we assert there is no such thing as dumb questions, there is such a thing as a lazy question. That is, when you are told to &quot;do x&quot; by person A, and then you go to person B and as &quot;hey, how do I do x?&quot; This might be seen as a lazy question, and not so cool to do it often. A good question should indicate that you have put some effort into the matter yourself, and are now seeking validation of your progress.\nAvoid the xy problem.\nSee <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#information-de-centralization-and-longevity\">Information (de)Centralization and Longevity</a>. In short, once you have asked a question, and have received your answer, think about how you can make this knowledge accessible to more people, and for a long time.\n\nüßë‚Äçüíª Contributing\n\n[!info] Public Contributor ~ Parity Employee\nThe information in this section is kept at minimum, as majority of what you have to know to contribute inside of Parity also applies to external contributors, and is already documented for them. Whatever is not documented, should be added to the same public medium and NOT be exclusive to a private Parity onboarding note.\n\nüõ£Ô∏è Road to Merging a PR\nFor your contribution, consider reading everything in our docs/contributing folder. What you do here is more or less what we expect external contributors to do:\n\nProper PR description, as per PULL_REQUEST_TEMPLATE.\nAdhering to everything in CONTRIBUTING.md.\n\n[!info] The stale PR issue\nA common issue that might arise is for you to open a PR, and for it to not receive the reviews you hoped for. While we are all obliged to spend a part of our time reviewing each others' code, we all tend to be busy as well. Opening a PR, yet silently letting it sit stale for a month is your foremost your shortcoming, not others'. Be vocal, both in public and with your manager/TL to ensure your PRs get the amount of review they deserve.\n\n[!info] Release and Audit Rooms\nTwo critical pieces of information about contributing to polkadot-sdk that is gated within Parity is being present in the release and audit Element rooms. These rooms ensure you are up to date with the latest of the two respectively, and can plan accordingly. Ideally, these processes should also move towards being as public as possible.\n\n[!tip] Editor Tips\nBe sure to read this (and this private) great guide about what editor setups we often use.\n\nüîô After Merging\nWell, your PR is finally merged. Are we done? More often than not, no.\nYet again, a lot of this goes back to the dual realities (<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#the-reality-of-what-we-do\">üíä The Reality of What We Do</a>) of our team: Flying low and flying close to end users. This implies that, before kissing and saying goodbye to a merged PR, you need to reflect on the following:\n\nTest-network Runtime Upgrade: Fairly soon after your PR is merged, it will be enacted on our test-networks, most notably Westend. This is your best opportunity to do your final round of (live) testing. Ask yourself: Is everything alright in Westend? How can I test my feature further?\nRC/SC Runtime Upgrade: Days, weeks or months after your PR is merged, it might finally land in the RC or one of the SCs[3]. This is another milestone for testing: Did everything go smoothly? The release process of RC runtimes, and their enactment, is fully public and managed by the Polkadot fellowship, so you can easily tag along.\nDeveloper Community Impact.\n\nDid any UIs break because of your feature? Could we have communicated better with them?\nAre any new documentation pages needed? (easier to forget:) Are any of the existing ones outdated now? Maybe one of the most visited StackExchange questions needs being updated?\nWas your PR description good for downstream teams to be able to adopt the feature?\n\nMonitoring and Data\n\nDevops Wiki A lot of great resources about our infra, and how to do monitoring of parity run nodes, validators, logs, and more!\nDotLake (public)\nMetabase (private)\n\nüßê Know Your API\nAs a final example to cement <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#the-reality-of-what-we-do\">üíä The Reality of What We Do</a>, let's consider the difference between two features, in order to highlight how important it is for you to be able to answer one question:\n\nIs my code end-user-facing or not?\n\nConsider:\n\nAn optimization made to the networking of the parachains protocol. This will improve the performance of parachain networking by 10%, without any action needed by anyone, as soon as the crate is released and updated. In such cases, be my guest, and ignore the majority of this rant. Your work is not directly affecting end-users. You can still demonstrate competence by adhering to everything said here, but a lot of it is not relevant.\nContrary, consider the following:\n\nWorking on a new major revision of any of the FRAME modules used by Polkadot end-users, such as staking, proxy or multisig.\nWorking on any feature that is expected to be integrated into wallets, exchanges, or other 3rd party software.\nChanged an API in FRAME or Substrate that might make existing code that compiles no longer compile.\n\nEven more pesky, existing correct code might still compile, but be incorrect if some upgrade path is not followed.\n\nOur PRDoc system's audience section is a good framework to help you think about the final audience of your code.\nMoreover, the new release process, with its emphasis on semantic versioning, will force you to think about this to a high extent, but it does not encapsulate the full magnitude of the above. For example, in your PR, you might be causing a major bump to many crates, but only one of the crates is something that actually matters to the main audience, noted in the PRDoc.\nüßπ Be The Housemeister\nWe are a true open-source project, and our entire issue-tracking system is what we publicly have in GitHub. While our issue list has grown very large, and it is unlikely that our team can clean it up, we can keep issues that are relevant to our team tidy, well described and properly labeled. Practically:\n\nKeep the issues that you have created tidy.\nKeep an eye on the issues opened by external contributors (they are auto-labeled as unconfirmed) and see if you can triage them. We sometimes get important bug reports from external users and the only way to do so\nSimilarly, you can have some degree of supervision upon areas of our StackExchange.\nKeeping a good list of mentor\n\nNeedless to say, most of this is not relevant to you at day-0, but it will become as you grow to be an expert in some domains.\n\nü§ì Keeping Up\nIn reality, you are joining the Polkadot ecosystem, not just Parity. And there is a lot happening in Polkadot! Some links for you to explore based on your interest in various topics:\n\nGovernance: Polkassembly, SubSquare, AAG.\nThe Kusamarian\nCommunity Element Chats:\n\nWatercooler, Direction, and Validator Lounge if you want more exposure\nAnd Kusama Watercooler, Direction.\n\nNewsletters: DotLeap.\nBill Laboon's Daily Digest.\nPolkadot Fellowship\n\nPublic Element Room 1, Room 2.\nGithub org, including manifesto.\n\nRust: This week in Rust, Rust in Blockchain.\n\nBe sure to see this: Interview with Senior Rust Developer in 2023 - YouTube if you are new to Rust üòÅüôà\n\nI personally like to follow these for general crypto stuff:\n\nDecrypt.\nPodcast: Defiant, Bankless and Unchained.\nCoinBureau‚Äôs weekly crypto update videos every Monday (yes, but it is good to know what the mainstream thinks..)\nBloomberg Crypto reports, Matt Levine Money Stuff.\n\nOfficial Polkadot Ecosystem Room in Element ‚Äî a fairly active chat with many parachain teams.\n\nüìç Company\nA few high level notes about the company, and not just the RF.\nüé≠ Culture\nYou will learn about the Parity culture in your onboarding, but here‚Äôs some old-but-still-relevant material from former culture decks.\nFirst, here‚Äôs a little screenshot of an all-hands talk about vision of Parity in 2019 which I still stand by. You can find the full talk here (most of it is not super relevant anymore).\n\nA culture talk from Gav in the 2022 Tenerife retreat. This snippet of this talk is among my favorites:\n\nYou can find the culture deck from 2022 here. If I wanted to name one slide from it that you should think about the most, it would be:\n\nThe majority of the efforts of your team lead, and this document is to help you toward achieving the status mentioned in the above sentence.\nüî¨ Parity XP\n\nParity XP contains links to everything else that is part of the internal org-wide onboarding.\n\nüíé Appendix: Principles For Excellence\n\nPersonal opinion of @kianenigma follows.\n\nThese are ideas that I believe will help you be excellent, and help others be the same. This is an opinionated re-iteration of some competencies that are noted in our CultureAmp.\nStability Over Chaos\nA theme in Polkadot in 2024 has been Stability. We used to say: &quot;We write code faster than we can write about it&quot;. Parity has always been a company known for engineering excellence, at the cost of lots of breaking changes. This all used to be cool, but not anymore. The best number of lines of new code to deliver a new feature is 0. The simpler, less-breaking a solution, the more elegant it is.\nInformation (de)Centralization and Longevity\nAs noted in <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#dumb-questions\">ü§™ Dumb Questions</a>, we acknowledge that there is a lot to be learned for all of us in this space. The underlying issue is that there is a lot of information centralization. Veterans in the space know a lot of things, yet the path for new joiners to learn the same is unclear and bumpy, and the constant evolvement of the space does not help.\nThe rule is: Once you have learned something, think about how you can make sure it is accessible to more people, and for a long time.\nThe best example of this is something that I personally do: Policing people to move good conversations and Q&amp;As from a small Element room to more permanent places. Every time I see a good technical question asked in our Element:\n\nIf this question is already asked in StackExchange, or in any of our docs, then I don't need to rewrite the answer. I will paste a link and move on.\nIf not asked, and I know the answer, I don't answer the question in chat, but instead ask the person to ask it in StackExchange, and only then answer.\n\nThis is merely one example, but the mentality it demonstrates is applicable to many situations. &quot;If you had to spend 1h answering a question, how can you make sure the next time someone has the same question, it takes them 1m?&quot;?\n\n[!info]- A Great Example\nIn H12024, Liam was working on the release process. There entirety of the acceleration department had constant questions about the status of this work, and how it would affect them.\nKeeping an eye on chats and answering question promptly would have been a responsible thing to do by Liam, but he even went a step further and recorded a quick Loom + FAQ and posted it in the forum. This ensures a lot of questions are answered all at once + it is not list in the history of some chat. This is a great example of working towards <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#information-de-centralization-and-longevity\">Information (de)Centralization and Longevity</a>.\n\nDomain Ownership\nTake radical and proactive ownership of what you have built, and be proud of it. We highly encourage engineers to grow a vision for what they are working on, and influence its future. This gives you a high degree of freedom to not only have a say on how some feature is implemented, but also which features are worthwhile.\nBut, freedom comes with responsibility:\n\nAs the owner of a domain, both internally and externally, you need to make yourself known as the owner, so that others can find you.\nFollow your domain carefully, participate in conversations around it, answer questions.\nYou need to interact with experts and higher level leaders both in Parity and the community to share your ideas and come to a conclusion about the future\n\n[!example]-\nFor example, if you aspire to be the owner of a domain, you would try to create notifications to be informed about all activity around this topic in the Polkadot forum, SE and twitter, and participate accordingly.\n\n[!info] Not For Everyone\nOf course this attitude of wanting a higher level of ownership and responsibility is not what everyone wishes, and is generally expected for an L5+ engineer.\n\nProper off-boarding and handover is also an important aspect of ownership. We move companies, teams, or sometimes, put a stop to an initiatives for various reasons. But what happens to the part of the project that is already out there? Should we bring it down? should we archive a repo? Prevent letting initiatives going stale.\nAnnounce Early\nIn tandem to the above, try and announce[4] what you are working on early, and embrace feedback. When you start an initiative, announce the vision, then link to a public Element room if one exists where one can join for a more in depth discussion about the project.\nDon't Be Blocked On Decisions\nSometimes it is hard to come up with an answer to an decision. Unless if it is a very irreversible one, you can do the following: Share what you think is the best approach, and if after x weeks no objections comes, you execute.\nMeasuring Impact\nThe impact of what we do, specifically for end-user facing work (as defined in <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/runtime-function-onboarding-2024/#know-your-api\">üßê Know Your API</a>), is NOT how many PRs we manage can merge into polkadot-sdk, but rather how much our code is being user by end-users or developers.\nLiveness Above All\nParity is a collective contributing to Polkadot. Most of us are part of other collectives that contribute to Polkadot in other ways, such as ChaosDAO or the Polkadot fellowship.\nMaking Polkadot successful is, one way or another, our main mission. Therefore, important bugs and existential issues that might arise should never be discarded as &quot;it is not the task I am working on, so not my problem&quot;. If something important comes up that is possibly an existential threat to Polkadot, it is everyone's first priority.\nResilience Above All\nWe proudly consider ourselves as one of the (few) companies that is &quot;doing blockchain right&quot;. In that, we are not in this for a short term profit, for capturing a hype or anything other than making the true Web3 vision come to fruition.\nAnd what is that Web3 vision: That we need to build the tools necessary to be able to build resilient systems that can survive the test of time. Blockchains are one important type of such systems.\nWe are also proud to be on the forefront of scalability of Blockchains, without sacrificing Resilience, something that we think other blockchain systems have deliberately opted to sacrifice.\nWith all that said, what is practically means for us, is that when we are developing runtimes and blockchains, making sure the system is sound, secure and sybil resistance is non-negotiable.\n\n[!Info]- But What About UX?\nHistorically, we have also sacrifices a lot of UX for resilience. We do wish to put a stop to that, and build more user-friendly systems going forward. That being said, we should similarly openly explore ways to improve UX without sacrificing resilience.\n\nLearning Resources\n\nPolkadot Blockchain Academy\n\nRecordings\nslides\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-s-build-horizon/\">Polkadot's Build Horizon</a>: Contains some up-to-date learning resources\n\nWrapping Up\nOkay, this was long! thank you for reading! for any feedback, reach out to @kianenigma.\n\nNotionally part of another team called node-sdk, but we contribute to the node side of Substrate as well. ‚Ü©Ô∏é\n\nBecause if all questions are dumb questions, then no questions are dumb questions. ‚Ü©Ô∏é\n\nThis is usually done in two steps: first, a release made by the Polkadot fellowship, and a runtime upgrade being authorized by the community. Parity coordinates these operations, but does not have full control over them. ‚Ü©Ô∏é\n\nAnnouncements should generally be done in the Polkadot forum, unless if for some reason it needs to be private, in which case it can be done in the Parity Forum. ‚Ü©Ô∏é",
		"tags": [ "note"]
},

{
		"title": "Building Blocks of the Web3 Cloud",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/post/tech/web3-platform-basics/",
		"content": "x.com/ayyyeandy/status/1907515511023292594\nPolkadot is increasingly pushing towards demonstrating itself as a general-purpose Web3 Cloud[1], rather than a (multi-chain) blockchain platform. This narrative further poses the question of what a general purpose blockchain cloud is and could become in the future.\nThis posts explores:\n\nWhat properties blockchain platforms can bring about, which in my methodology end up being\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/post/tech/web3-platform-basics/#correct-secure-computation\">#Correct/Secure Computation</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/post/tech/web3-platform-basics/#ordering-consistency\">#Ordering/Consistency</a>\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/post/tech/web3-platform-basics/#canonical-state\">#Canonical State</a>\n\nAnd at what cost we can achieve each of them\nWhat applications can actually be built with these primitives?\n\nMy motivation in writing this is that I increasingly see even engineers and decision-makers not having a clear understanding of what it actually is that they are building. The criticism towards Web3 being vaporware is increasing, Consequently, I see products being fitted into Web3 with requirements that are not met by blockchains, exacerbating the criticism. Frankly, some of us are, sadly, creating vaporware, and it is rooted in our lack of understanding of the technology. This post aims to be a small towards filling this knowledge gap. In the last year or so, I have examined the above question, and I have formulated my answer to it, which I will describe in this blog post. More is to be said about it, so expect more follow-ups üìù.\n\n[!note] Opinions Differ\nMy opinions here are rather traditional. Recent founders and decision makers of the Web3 space might think differently, and are more willing to question the properties that I explain below. I think there is merit to both types of thinking, and both can positively help a clear-minded decision.\n\nCorrect/Secure Computation\nBlockchains are, at the core of them, a more resilient TEE. You can give them some code (a set of rules), and they execute that code correctly for you. You can be sure about the correct execution of that code, and the security of it is a function of the economic security (in PoS) or hash power (in PoW[1:1]), or math magic (SNARK proofs). All the said 3 technologies (PoW, PoS, SNARK proofs) are a way to ensure some execution actually happened correctly. In the former two we rely on economic incentives, in the latter in a mathematical proof.\nAn age-old example that I find useful to remember all the time: I can run a 50 lines python script that has the same logic as the BTC token, and run it on my computer. Why don‚Äôt we trust this to be trustworthy, yet trust the same logic executed by Bitcoin miners to be trustworthy? What‚Äôs the difference? Correct Computation through PoW. The same applies to Polkadot and its parachain, Ethereum and its Solidity contracts, and Solana and its SVM contracts. I could be running the exact same contracts and parachains on my machine, yet we don't trust me to do it correctly.\nNext, let's explore the properties and consequences of <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/post/tech/web3-platform-basics/#correct-secure-computation\">#Correct/Secure Computation</a>.\nMulti-Party Contention\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/post/tech/web3-platform-basics/#correct-secure-computation\">#Correct/Secure Computation</a> is mainly useful for any kind of application that involves contentious computation between multiple parties. That is, multiple humans are performing a value-breading transaction with one another, and are sufficiently unfamiliar with one another, such that they don't trust each other.\n\nIf writing it as a python script and running it on my server is good enough for Joe to interact with it, then running it on a blockchain for Joe to interact with it is a needless overhead.\n\nWe have not seen single-party applications on Blockchains yet, and I am doubtful if/how they will work. If it is just my data, my computation, and my interactions with it, I am not sure why I would want to host it on a blockchain, vs. a self-hosted solution on my server (if I am privacy-concerned). A good example here is applications like personal note-taking, password managers and so on. These applications don't involve any multi-party contention. It is all about a single individual's interactions with their private data.\nExpensive\nAchieving this TEE-equivalent property is not cheap. It requires either a combination of re-execution + economic security, or expensive SNARK proving that we see in the Ethereum space[2]. So the blockchain computer is, compared to your computer, extremely slow. It is a trustworthy, slow computer, that so far we know can be given some code, and it can execute that code correctly.\nPublic By Default\nIf we use the economic security method for achieving correct computation, there is no way around the fact that it has to be public, at least to the validators of the said blockchain executing the operation. There is no way to do a balance transfer without making it public to at least the validators of the network that is executing it, so they can verify through re-executing it.\nNote that the ZK-SNARK method is different, because the computation is essentially happening outside the validator group, and an anonymized proof is verified by the validators, with control over what part of the computation can be made public. In the case of an ZK-Rollup, the (often centralized) sequencer generates the proof. In dark-fi, it actually seems to happen on the user‚Äôs machine itself (ref). I am not very familiar with the constraints of this computation method at present.\nIf proof generation becomes so cheap that any user/wallet/dapp can generate the proof of their correct computation, this whole section around ‚ÄúCorrect Computation‚Äù and using economic security to achieve it will become useless.\nDigital, Digital And Finally Digital\nSomething that I found to be poorly understood is that blockchains are at the end of the day a digital system. It can ensure the correctness of some bits in computers and nothing in the real world. Linking real world assets and objects to blockchains is not sensible unless a robust oracle that can both read real world information, and enforce updates to the real world (neither of which exist at present) exists.\nI think all the ‚Äúlet‚Äôs tokenize this apartment and my rolex and put it onchain‚Äò is all a dead end, and the result of misled decision makers not understanding the technology on which they are building.\nOrdering/Consistency\nEven if we have a blockchain-based computer that executes some code correctly, there could be two parallel states that are both ‚Äúcorrect according to the code‚Äù, but we need to choose which one we stick to. Correct ordering is the second main property of blockchain platforms.\n(usually) Auditable\nThis history of execution is fully auditable, and any other network participant is capable of combining the ‚ÄúCorrect Execution‚Äù and ‚ÄúOrdering‚Äù to re-verify the whole thing.\nIn fact, the main purpose of the data-structure known as a blockchain is used in this part. Excluding ordering, I can have a PoS system that delivers ‚Äúcorrect execution‚Äù while not using blockchains at all.\nCanonical State\nThis computer has access to a storage primitive that we know as the state. We can think of it as the persistent memory that the said code has access to.\nExpensive\nSimilar to the computation aspect, anything that we store in the state is much more expensive than a normal computer platform. At the least, it has the replicated many times. It is also stored in ways (e.g. merklized) that are not particularly performant.\nPublic\nAnything that goes into this state is public and visible to anyone else in the network.\nNo Private partition\nA typical web2 service holds the entire state of the system private, and when a user authenticates themselves, a portion of the state is exposed to them. Any web3 storage cannot really benefit from this, and there is no partitioning. The only way to achieve partitioning is to leverage public key encryption. But then you have to remember that unless if you are using ZK for execution, at least the validator needs to have access to the unencrypted information to verify whatever it is executing.\nProvable\nA very nice property of this state is that you can cheaply generate proofs about a subset of it to anyone else. See here.\nEvolution of Blockchain State Transition Function\nThe main pillars discussed so far:\n\nCorrect Execution\nCanonical And Auditable Ordering\n\nCombined is mainly why we model blockchain systems as state machines. It is a state machine that is guaranteed to have one correct final state. This leads to us modeling the business logic of the blockchain as the state transition function of a state machine. Then, let‚Äôs look at the evolution of this STF.\n\nFixed: Bitcoin, Litecoin, Monero etc. Any blockchain that has one fixed function, and it only does that.\nProgrammable, while exposing the underlying blockchain platform: All smart contract platforms, Polkadot Parachains, Substrate solo-chain, Ethereum and L2s. All of these are means to make the blockchain platform programmable, but none of them go as far as hiding the fact that you are running a blockchain.\nProgrammable, while hiding the underlying blockchain platform: JAM+CoreVM and ICP are the only projects that have taken steps in hiding the fact that you are running on a blockchain.\n\nI think in retrospect this is absurd how much of implementation (blockchain) is leaking into abstraction (applications built on top): As said above, blockchain is a data-structure used to create the property of canonical ordering. Correct execution, which to me is the main property, is independent of blockchains.\nBeyond Canonical State\n\nDA: same properties as the state + cheaper + but ephemeral\nSome storage chains that work on the basis of being an incentive layer on top of IPFS. def. Has some different properties than Canonical state.\n\nhttps://eigerco.github.io/polka-storage-book/getting-started/demo-file-store.html\n\nhttps://forum.polkadot.network/t/introducing-storage-hub-a-system-parachain-optimised-for-storage/4525/12 W3F grant, asked lead for a meeting to see what they are up to.\nSubstrate based storage chain that Arkady worked on, and I think is being implemented in the PoP‚Äôs bulletin chain.\n\nSummary\nMy motivation in putting this together is to deeply understand what are the properties that blockchain platforms excel at, and then find existing/new use cases that are in fact a fit for these properties. In other words, we should have an educated guess on what use cases fit blockchains, rather than blindly searching in the dark.\n\nInterestingly, Proof of Work is essentially the same as economic security represented in the form of hardware and electricity ‚Ü©Ô∏é ‚Ü©Ô∏é\n\nat present proving fn(x) -&gt; y is millions/many-thousands of times more expensive than executing fn(x) directly ‚Äì see here ‚Ü©Ô∏é",
		"tags": ["Correct/Secure", "Ordering/Consistency", "Canonical", "Correct/Secure", "Correct/Secure", "note"]
},

{
		"title": "Demystifying JAM",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/demystifying-jam/",
		"content": "[!tip] Translations / Re-Publishing\nThe following are further translations of this article:\n\nKorean\nChinese\nParity's Website\nPolkadot Twitter\nShorter presentation version at Sub0 Bangkok 2024 <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/presentation/\">Demystifying JAM - Presentation</a>\n\nFull Recording\n5 Mins Summary\n\nFeel free to share your re-publications in a comment down below to be featured here!\n\n[!info]- Collaboration\nIf you would like to collaborate on this article and/or leave feedback, consider opening a Pull Request here.\n\n[!info]- Diagrams\nThe diagrams provided in this article are all SVG files and can be downloaded directly from the HTML source and adopted to a different style guide. You can also access all of the drawings here.\n\nThe following is a ground-up explanation of Polkadot 1, Polkadot 2, and how it will evolve to JAM. It is targeted towards a technical audience, but more so those that are not very familiar with Polkadot, but have a good high level understanding of blockchain based systems, and are possibly familiar with one other ecosystem at a technical level. I believe reading this can be a great prelude before reading the JAM graypaper.\nBackground Knowledge\nThis article makes use and assumes familiarity of the following concepts:\n\nDescribing a blockchain as a state-transition function.\nUnderstanding of what is &quot;State&quot;\n\nBoth explained here.\n\nEconomic Security and Proof of Stake.\n\nExplained in this PBA lecture, recording\n\nPrelude: Polkadot 1\nFirst, a recap of what I consider the top novel features of Polkadot 1.\n\nSocial:\n\nPolkadot is one massive DAO by all means. The network does fully onchain, self-enacting governance, including fork-less runtime upgrades.\nDOT considered a software, not security by the SEC.\nMajority of network development is done by the Polkadot Fellowship, not a fiscal company (e.g. Parity).\n\nTechnological:\n\nShared security, sharded execution.\nUse of a WASM-based meta-protocol. Storing the code of the blockchain in the state as byte-code. This enables most upgrades to be fork-less, and supercharges Polkadot to be, not only sharded, but heterogeneous sharded. More on this in <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/#heterogenous\">Heterogenous</a>.\n\nLet's dive further into sharded execution and what we mean by it.\nSharded Execution: All About Cores\n\nFor now, we are talking in the context of an L1 network that hosts other L2 &quot;blockchain&quot; networks, much like Polkadot and Ethereum. Therefore, the words L2 and Parachain can be used interchangeably.\n\nThe core problem with blockchain scalability can be stated as: There exists a set of validators, whose execution of some code can be trusted through crypto-economics of proof-of-stake. By default, these validators are expected to re-execute the entirety of each other's work. Therefore, the system as a whole is not scalable so long as we force all validators (re)execute everything at all times.\nNote that increasing the number of validators in this model doesn't really increase the system's throughput, so long as the above absolute re-execution principle is in place.\n\nThe above demonstrated a monolithic (as opposed to sharded) blockchain. Inputs (i.e. blocks) are processed by all network validators, one by one.\nIn such a system, if the L1 wants to host further L2s, all validators have to now re-execute the work of all L2s as well. Obviously, this will not scale. Optimistic rollups are one way to circumvent this issue, in that re-execution (aka. fraud-proofs) only happen if someone claims a fraud to have happened. SNARK-based rollups circumvent this by leveraging the fact that verifying a SNARK proof is significantly cheaper than generating it, and therefore it is reasonable to allow all validators to verify a SNARK proof. More about this in <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/#appendix-scalability-space-map\">Scalability Space Map Appendix</a>.\nA naive solution to sharding is to merely split the validator set into smaller subsets, and have this smaller subset re-execute L2 blocks. What is the issue with this approach? We are sharding execution and economic security of the network. The security of such an L2 is less than that of the L1, and the security drops further and further as we carve up the validator set into more shards.\n\nContrary to optimistic rollups that cannot afford re-execution at all times, Polkadot was designed with execution sharding in mind, and therefore can have a subset of its validators re-execute L2 blocks, whilst providing sufficient crypto-economical evidence to all network participants that the veracity of the L2 block is as secure as if the entire set of validators had re-executed it. This is possible through the novel (recently formally published) ELVES mechanism.\nIn short, one can see ELVES as a &quot;Cynical Rollup&quot; mechanism. Through a few rounds of validators proactively asking other validators if an L2 block is valid, we can reach an extremely high probability that the L2 block is valid. Indeed, in case of any disputes, very soon the entire validator set is asked to participate. This is explained in detail in an article by Rob Habermeier, Polkadot co-founder.\nELVES is why Polkadot can have two properties previously assumed to be mutually exclusive: &quot;Sharded Execution&quot;, with &quot;Shared Security&quot;. This is the main technological outcome of Polkadot 1 when it comes to scalability.\n\nNow, moving on to the &quot;Core&quot; analogy.\nAn execution-sharded blockchain is very much like a CPU: In much the same way that a CPU can have many cores that execute instructions in parallel, Polkadot can progress L2 blocks in parallel. This is why an L2 on Polkadot is called a Parachain[1], and the environment in which the smaller subgroup of validators re-executes a single L2 block is called a &quot;core*. Each core can be abstracted as &quot;a group of validators working in coordination&quot;.\nYou can imagine a monolithic blockchain as one that ingests a single block at any given time-slot, while Polkadot ingests 1 relay-chain block, and 1 parachain block per core, per time-slot\nHeterogeneous\nSo far, we only talked about scalability, and that Polkadot provides sharded execution. It is important to note that each of Polkadot's shards is an entirely different application[2]. This is achieved through the usage of a bytecode-stored meta-protocol: A protocol in which the definition of the blockchain is stored as bytecode in state of the blockchain itself. In Polkadot 1.0, WASM was used as the bytecode of choice, and in JAM, <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/#pvm\">PVM</a>/RISC-V is being adopted.\nAll in all, this is why Polkadot is called a heterogeneous sharded blockchain. Each of the L2s is an entirely different application.\n\nPolkadot 2\nA big part of Polkadot 2 is about making cores more flexibly use-able. In the original Polkadot model, a core could have been rented for 6 month up to 2 years at a time. This is suitable for resourceful businesses, but less so for small teams. The feature that enables Polkadot cores to be used in a more flexible way is called &quot;agile coretime&quot;. In this model, Polkadot cores can be rented for as little as one block at a time, up to a month at a time, with price cap guarantees for those that want to rent for long term.\n\nPolkadot 2, among other features, is unfolding as we speak, and not much further needs to be said about it here.\nInside Core vs. On the Chain\nTo understand JAM, it is first useful to look into what happens in a Polkadot core when an L2 block comes in.\n\nThe following contains a lot of simplification.\n\nRecall that a core is constituted primarily from a group of validators. So, when we say data is sent to the core&quot;, it is gossiped to this group of validators.\n\nAn L2 Block + a subset of that L2's state is sent to the core. This is all the data that is needed to execute the L2 block[3].\nA subset of validators, those that constitute the core, re-execute the L2 block and proceed with further consensus related tasks.\nThe core validators make the data needed for re-execution available to other validators (outside the core). Further validators might decide to re-execute this L2 block based on ELVES rules, and they need the data to do so.\n\nNote that all the operation so far is outside the Polkadot's main block and state transition function. Everything so far happens inside a core, and the data availability layer.\n\nEventually, a small commitment of the L2's latest state becomes visible on the main Polkadot relay chain state. This operation, which is much cheaper than the actual re-execution of the L2 block, unlike everything else so far, affects the main Polkadot state, becomes visible in a Polkadot block, and is executed by all Polkadot validators.\n\nFrom the above, let's explore some of the operations that Polkadot is performing:\nFrom 1, we can learn that there exists a new type of execution in Polkadot that differs from normal blockchain state transition function. Typically, when all validators of a network execute some work, and as the outcome the main blockchain state is updated. We call this an on-chain operation. This is what happens in step 3. Yet, what happens inside a core (step 1) differs from this. We call this novel type of blockchain computation in-core execution.\nNext, from point 2 we can deduce that Polkadot already provides a native Data-Availability (henceforth DA) layer, and L2's automatically use it to keep their execution evidence available for some period of time. Yet, the blob that can be posted to this DA[4] layer is fixed, and it is always the evidence needed to re-execute an L2 block. Moreover, parachains's code never read from the DA layer.\nUnderstanding the above is foundation of understanding majority of what JAM does. To recap:\n\nin-core execution: What happens inside a core. Abundance, scalable, as secure as on-chain execution through crypto-economics and ELVES.\non-chain execution: What happens in all validators. Secured by default through economically secured validators. More expensive and constrained, as everyone is executing everything.\nData Availability: The ability for Polkadot validators to commit to having some data available for some period of time, and providing it to other validators.\n\nJAM\nWith the understanding gained in the previous section, we can smoothly transition into what JAM is.\nJAM is a new protocol, heavily inspired by Polkadot, and fully compatible with it, aiming to replace the Polkadot relay chain and make the usage of cores radically un-opinionated[5].\nJAM builds on top of <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/#polkadot-2\">Polkadot 2</a>, in that it tries to make Polkadot cores more accessible, but in ways radically more flexible and un-opinionated than agile-coretime.\n\nPolkadot 2 makes the deployment of L2s more flexible on cores.\nJAM is all about deploying any application on Polkadot cores, even those that don't resemble a blockchain/L2.\n\nThis is primarily achieved through exposing all the main 3 primitives discussed in the previous section to programmers, namely: on-chain, in-core, and the DA layer.\nIn other words, in JAM, developers are exposed to:\n\nAllow both the work that is being done in-core and on-chain to be fully programmable.\nAllow arbitrary data to be read-from and written-into the Polkadot DA layer.\n\nThis is a foundational description of what JAM aims to be. Needless to say, a lot has been simplified here, and the protocol might still evolve.\nWith this foundation in mind, we can now dive further into a few details of JAM in the coming sections.\nService and Work Items\nThis is why in the context of JAM, what used to be called an L2/Parachain is now called a Service, and what used to be called block/transaction is now called Work-Item or Work-Package. Concretely, Work-Items belong to a Service, and Work-Package is a group of Work-Items. Both terms are deliberately chosen to be generic enough to encapsulate use-cases beyond a blockchain/L2.\nA service is described by 3 entry points, two of which are fn refine() and fn accumulate()[6]. The former describes what the service does in-core, and the latter describes what the service does on-chain.\nFinally, the name of the two entry-points is why the protocol is called JAM: the Join Accumulate Machine. Join is fn refine(), when all Polkadot cores do a lot of work, all in parallel, for different services. Join is when the data is distilled into a smaller subset, and is then passed onto the next stage. Accumulate is when the result of all the aforementioned are accumulated into the main JAM state. This is the on-chain execution part.\n\n[!tip] Work-items can specify exactly what code they execute in-core, on-chain, and if/how/what they read and write to/from the Distributed Data Lake.\n\nSemi Coherence\nRecall from existing material around XCM, Polkadot's language of choice for parachain communication, that all such communication is asynchronous. That is, a message is sent, and its reply cannot be waited upon.\nAsynchrony is the manifestation of an incoherent system, and is a major drawback of systems that are permanently sharded, such as Polkadot 1 and Polkadot 2 and the existing L2 landscape in Ethereum.\nYet, as described in the graypaper section 2.4, a fully coherent system that is always synchronous for all of its tenants can also only grow so much without compromising generality, accessibility or resilience.\n\n[!info] Synchronous ~ Coherent || Asynchornous ~ Incoherent\n\nThis is another area where JAM stands out: through the introduction of multiple properties, JAM achieves a novel middle-ground: a semi-coherent system, one in which sub-systems that communicate often have a chance at creating a coherent environment with one another, whilst not enforcing the entire system to be coherent. This is best described in this interview with the Dr. Gavin Wood, the author of the graypaper:\n\nAnother way to look at this is to see Polkadot/JAM as a sharded system where the boundaries of those shards are fluid, and determined on the fly.\nPolkadot has always been sharded, and fully heterogenous. Now, it will be sharded, heterogenous, AND the boundaries of those shards can be determined flexibly, what @gavofyork is referring to as semi-coherent system in https://t.co/tjAboJL9IA&mdash; Kian Paimani (@kianenigma) May 15, 2024\nThe properties that enable this are:\n\nAccess to both a state-less, parallel in-core execution where different services can only interact synchronously with other services that reside on the same core in that particular work-package, and on-chain execution where a service has access to the outcome of all services across all cores.\nJAM does not enforce any particular scheduling of services. Services that talk to each other frequently can create an economic incentive for their sequencers to create WorkPackages that contain WorkItems of services that often communicate. This enables them to reside in the same core, and in practice, talk to each other as-if they were in a synchronous environment.\nMoreover, JAM services have access to the DA layer and can use it as an ephemeral, yet extremely cheap data layer. Once a data is placed in the DA, it is eventually propagated to all cores, but is guaranteed to be available in that same core immediately. Therefore, JAM services, through scheduling themselves into the same core in consecutive blocks[7], can enjoy a much higher degree of access to data.\n\nIt is important to note that while the above is possible in JAM, it is not enforced at the protocol layer. Therefore, it is expected that certain interfaces are asynchronous in theory, but can act synchronously in practice through elegant abstractions and incentives. One such example in CorePlay, discussed in the next section.\nCorePlay\nThis section describes CorePlay, an experimental idea in the context of JAM, which can be described as a new model for programming smart contracts. CorePlay is, at the time of writing, un-specified[8] and remain an idea.\nTo understand CorePlay, we need to first introduce JAM's virtual machine of choice, PVM\nPVM\nAn important detail of JAM and CorePlay is Polkadot Virtual Machine, PVM for short. Low level details of PVM are beyond the scope of this article and are best described in the graypaper by the domain experts. Yet, for the sake of this article, we only have to elaborate on a few properties of PVM:\n\nEfficient metering\nAbility to pause and resume execution\n\nThe latter is particularly important for CorePlay.\nCorePlay is one example of using JAM's flexible primitives to create a synchronous and scalable smart contract environment with a very flexible programming interface. CorePlay suggests deployment of actor-based smart contracts directly on JAM cores, and enabling them to enjoy a synchronous programming interface whereby they can be coded as a normal fn main(), in which they can communicate using let _result = other_coreplay_actor(data).await?. In the case other_coreplay_actor is in the same core in that JAM block, this call is synchronous, and in case in another care, the actor is paused and will be resumed in a later JAM block. This is precisely possible because of JAM services and their flexible scheduling, and PVM's properties.\nCoreChains Service\nFinally, let's wrap up by reminding all readers of the main reason why we mentioned JAM is fully compatible with Polkadot. The main product of Polkadot is Parachains in the agile-coretime fashion, and this product persists in JAM.\nThe first service that will be deployed in JAM is likely to be one that is called something along the lines of CoreChains or Parachains. This is the service that will allow existing Polkadot-2-style parachains to be executed on JAM.\nFurther Services can be deployed on JAM, and the existing CoreChains service can communicate with them, but the existing product offering of Polkadot will remain strong, and only new doors will be opened to existing Parachain teams.\n\nAppendix: Data Sharding\nThe majority of this article covered the topic of scalability from the perspective of execution sharding. We can also look at the same in the context of data. Interestingly, we find a similar situation as with what was mentioned in <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/#semi-coherence\">Semi Coherence</a>: A fully coherent system is better in principle, but does not scale. A fully incoherent system scales, but is not desirable, and JAM, with its semi-coherent model, poses a new possibility.\nFully Coherent System: This is what we see in a fully synchronous, smart contract platform, like Solana, or those brave enough to only deploy on Ethereum L1. All the application data is stored on-chain, and is easily accessible to all other applications. A perfect property for program-ability, but not scalable.\nIncoherent System: Application data is kept outside the L1, and in different, isolated shards. Extremely scalable, but not great for composability. Polkadot and the Ethereum rollup model.\nJAM, other than providing both of the above, also allows programmers to post arbitrary data into the JAM DA layer, which in some sense is a middle-ground between on-chain and off-chain data. A novel category of applications can be written while leveraging the DA layer for majority of the application data, while only persisting what is absolutely crucial into the JAM state.\nAppendix: Scalability Space Map\nThis part re-explain our view on the blockchain scalability landscape. This is also explained in the graypaper, and this is a more concise version of that.\nThe scalability in blockchains follows the approaches used in traditional distributed systems for the most part: scaling up (vertical), and scaling out (horizontal).\nScaling up is what the likes of Solana are doing. Hyper optimize both the code, and the hardware to achieve maximal throughput.\nScaling out is what Ethereum and Polkadot are doing: Reducing the amount of work that has to be done by everyone. In a traditional distributed system, this is done by adding more replicated machines. In blockchains, the &quot;computation machine&quot; is the entire validator set of a network. By splitting work between them (what ELVES does), or optimistically discounting their duties (what optimistic rollups do), we are reducing the workload on the entire validator set as a whole, and therefore scaling out the system.\n\n[!info] Scaling out in blockchains is analogous to &quot;reducing the number of machines that have to execute everything&quot;.\n\nTo summarize:\n\nScaling up: Beefy hardware + optimization in a monolithic blockchain.\nScaling out:\n\nOptimistic rollups\nSNARK-based rollups\nELVES: Polkadot's cynical rollups\n\nAppendix: Same Hardware, Kernel Update\nThis section builds on top of an analogy provided by Rob Habermeier in Sub0 2023: Polkadot: Kernel/Userland | Sub0 2023 - YouTube, and demonstrates what JAM, as an upgrade is to Polkadot: a Kernel Update on top of the same hardware.\nIn a typical computer, we can divide the entire stack into 3 segments:\n\nHardware\nKernel\nUserland\n\nIn Polkadot, the hardware, the essence of what provides computation and data availability has always been cores, as described above.\nThe kernel in Polkadot, in practice[9], so far has consisted of two things:\n\nThe parachains protocol. An opinionated, rigid way to use cores.\nA set of low level functionalities, such as the DOT token and it transfer-ability, staking, governance and alike.\n\nBoth of these are what today resides in the Polkadot relay chain.\nThe userland applications are finally instances of parachains, their native tokens, and whatever else is built on top of them.\nWe can visualize this as follows:\n\nPolkadot always envisioned moving more of its core functionality to its first class user, parachains. This is what the Minimal Relay RFC aims to achieve.\n\nThis implies that the Polkadot relay chain deals only with providing the parachains protocol, somewhat shrinking the kernel space.\nOnce this architecture is achieved, it is easier to visualize what JAM migration would look like. JAM would drastically shrink the kernel space of Polkadot, and make it more general-purpose. Moreover, the parachains protocol is moved to the user space and because merely one of the only ways that applications can be written on top of the same cores (hardware) and kernel (JAM).\n\n[!info] This should also, one last time, illustrate why JAM is a replacement only for the Polkadot relay chain, and not the parachains.\n\nIn other words, we can see the JAM migration as a kernel upgrade. The underlying hardware remains the same, and a large chunk of the old kernel is moved to the userland for simplicity.\n\nResources\n\n7.9 Polkadot 2.0: CorePlay, CoreChains, Corejam, Safrole, PolkaVM - Polkadot by Gavin @PBA4 - YouTube\nGavin Wood: The Gray Paper Interview - JAM &amp; the Future of Polkadot - Behind the Code: Web3 Thinkers - YouTube\n\nParallel Chain. ‚Ü©Ô∏é\n\naka. Blockchain, or state transition function. ‚Ü©Ô∏é\n\nIn Polkadot 1.0 we called the L2's state proof PoV (Proof of Validity), and the combination of the state proof and the parachain block PVF (Parachain Validation Function). ‚Ü©Ô∏é\n\nNote that the graypaper calls this DA layer, the Distributed Data Lake, DDL for short. For the sake reducing the number of new keywords in the article, we continue to refer to it as DA, or DA Layer. ‚Ü©Ô∏é\n\nIt is crucial to point out that JAM is only meant to replace the Polkadot relay chain. Parachains, and all applications that run on top of Polkadot remain intact, mainly thanks to <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/#core-chains-service\">CoreChain</a>. ‚Ü©Ô∏é\n\nAnd the 3rd one being an on_transfer, which is called when a message from another service arrives. ‚Ü©Ô∏é\n\nFor more information about the scheduling of services, see the &quot;Authorization&quot; section in the graypaper. ‚Ü©Ô∏é\n\nThe best written resource on CorePlay is this draft RFC. ‚Ü©Ô∏é\n\nEmphasizing the word &quot;in practice&quot;, as even in the aforementioned talk, Rob denotes the parachain protocol as Userland application of Polkadot. But, this is a theoretical assumption and the parachains protocol has been well baked into the core Polkadot protocol, i.e. the kernel itself. ‚Ü©Ô∏é",
		"tags": [ "note","polkadot","jam"]
},

{
		"title": "For Those Who Don't Want rust-analyzer - One Regex to rule them all",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/for-those-who-don-t-want-rust-analyzer-one-regex-to-rule-them-all/",
		"content": "I was recently emailed by someone who had seen one of my crowdcast seminars on substrate, and asked me to share my Rust setup in vs-code for finding symbols and jumping to references. Before answering a simple &quot;I use rust-analyzer as well&quot;, I looked into the video and I realized that I, indeed, was not using it at the time. A long time before that video was recorded, I had given up on using rust-analyzer for substrate because simply it was such a massive mono-repo that even without any CheckOnSave, or overwriting the check command to use cargo-remote, it was too much for my laptop to handle.\nAt that point, I developed two simple regex-based shortcuts to fill the gap for me, and I want to\nuse the reply to this email to share it with a broader audience as well, since there could still be\nmany people out there for whom running rust-analyzer is too expensive because of huge repositories, or limited hardware resources. So, here it goes!\nFirst, we need a regex that can match symbols. You probably know where very that the moment that you have generics in your code, searching for something like Impl Something for SomethingElse no longer works, because there are a lot of generics (&lt;T: ...&gt;) in the same line. I took the fix for this (which is just adding &lt;.*?&gt; to your regex search) and expanded it to match as many type declarations as possible, among a few other things. At the end, I settled on:\n(macro_rules!|const|enum|struct|fn|trait|impl(&lt;.*?&gt;)?|type)\n\nBut having to paste/type the regex every time is not super nice, so I found a shortcut that\nwould have this ready for me in the global search, with regex mode available:\n// add this to your `keybindings.json`\n{\n\t&quot;key&quot;: &quot;cmd+shift+h&quot;, // you can and should use whatever you want here.\n\t&quot;command&quot;: &quot;workbench.action.findInFiles&quot;,\n\t&quot;args&quot;: {\n\t\t&quot;query&quot;: &quot;(macro_rules!|const|enum|struct|fn|trait|impl(&lt;.*?&gt;)?|type) &quot;,\n\t\t&quot;isRegex&quot;: true,\n\t\t&quot;triggerSearch&quot;: true,\n\t\t// &quot;filesToInclude&quot;: &quot;${relativeFileDirname}&quot;, // no variables in findInFiles\n\t\t&quot;preserveCase&quot;: true,\n\t\t&quot;useExcludeSettingsAndIgnoreFiles&quot;: false,\n\t\t&quot;isCaseSensitive&quot;: true,\n\t\t// &quot;matchWholeWord&quot;: true,\n\t\t// &quot;filesToExclude&quot;: &quot;&quot;\n\t}\n}\n\nThis allowed me to quickly go from: I have type name Foo in my head, I want to find its\ndefinition real quick.\n\nBut, one of the greatest magics of any IDE or rust-analyzer is that you get that juicy jump to\ndefinition, and I could not yet mimic that, but at least tried! The next shortcut will allow you to\ndo exactly the same thing as the previous shortcut, but do it for the current highlighted keyword:\n{\n\t&quot;key&quot;: &quot;cmd+shift+g&quot;,\n\t&quot;command&quot;: &quot;search.action.openNewEditor&quot;,\n\t&quot;args&quot;: {\n\t\t&quot;query&quot;: &quot;(macro_rules!|const|enum|struct|fn|trait|impl(&lt;.*?&gt;)?|type) ${selectedText}&quot;,\n\t\t&quot;isRegexp&quot;: true,\n\t\t&quot;showIncludesExcludes&quot;: true,\n\t\t&quot;triggerSearch&quot;: true,\n\t\t&quot;contextLines&quot;: 2,\n\t\t&quot;focusResults&quot;: true,\n\t},\n\t&quot;when&quot;: &quot;editorTextFocus&quot;\n}\n\nAnd then in the search result page, the default Jump to Definition would just work, which you can configure again to be any key that you want.\n\nBonus: shortcuts to navigate the results\nOver time, I learned that shortcuts to navigate through both local and global search are super\nuseful. You can already see me use them in the previous gif. Highly recommended to set them to a keyboard shortcut that you can easily remember and readily use. These are the related keyboard shortcuts:\n{\n\t&quot;key&quot;: &quot;ctrl+'&quot;,\n\t&quot;command&quot;: &quot;editor.action.nextMatchFindAction&quot;,\n\t&quot;when&quot;: &quot;editorFocus&quot;\n}\n{\n\t&quot;key&quot;: &quot;ctrl+.&quot;,\n\t&quot;command&quot;: &quot;search.action.focusNextSearchResult&quot;,\n\t&quot;when&quot;: &quot;hasSearchResult || inSearchEditor&quot;\n},\n{\n\t&quot;key&quot;: &quot;ctrl+,&quot;,\n\t&quot;command&quot;: &quot;search.action.focusPreviousSearchResult&quot;,\n\t&quot;when&quot;: &quot;hasSearchResult || inSearchEditor&quot;\n},\n{\n\t&quot;key&quot;: &quot;ctrl+c&quot;,\n\t&quot;command&quot;: &quot;search.action.clearSearchResults&quot;\n},\n{\n\t&quot;key&quot;: &quot;ctrl+;&quot;,\n\t&quot;command&quot;: &quot;editor.action.previousMatchFindAction&quot;,\n\t&quot;when&quot;: &quot;editorFocus&quot;\n},",
		"tags": [ "note"]
},

{
		"title": "Multi-Chain SDK Vision",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/multichain-api/",
		"content": "A quick brain-dump around what I would describe as an API for the &quot;Polkadot Network&quot;.\nThis is mostly a summary of the PAPI discussions here and here, but I have posted the meat here as it might be relevant to all SDKs such as polkadot-js-api and paritytech/subxt, not just PAPI.\nWhat is Polkadot Network\nGoing forward, the Polkadot network is not the Polkadot relay chain anymore, and it is not AssetHub. It a combination of system chains that might fluidly decide to scatter themselves further (example: Staking functionality moving to a different system parachain), or unify to achieve synchrony (example: Coretime chain merging into AH).\nSo, Polkadot Network is not the relay chain, and it is not a specific system chain. It is the combination thereof. In this view, a proper SDK is one that abstracts away over, not a pallet, not a single chain, but rather over the entire network, the red dashed circle below.\n\nAPI For The Polkadot Network\nWith that definition in mind, let's consider:\nThe &quot;Polkadot Network&quot; (!= relay chain) as a whole always provides the following list of functionalities:\n\nQuery and transfer of the DOT token.\nStaking the DOT token\nAbility to vote on a referendum with the DOT token\n\nThe goal should be to provide an API that is abstract over &quot;on which chain each of these functionalities reside&quot;, but rather the mere fact that &quot;They exist somewhere in the Polkadot network&quot;.\ndotApi = await new PolkadotNetwork();\n{ transferrable, reserved } = dotApi.balance_of(&quot;kian&quot;);\n\n// options for staking, such as who you want to supprot.\nopts = {}\nresult = dotApi.stake(transferrable / 2, opts);\n\nNotice in the above, I do not specify a network, or a pallet. I merely ask the &quot;Polkadot Network, please tell me how much DOT I have in your entirety.\nEasier Said Than Done\nThe above basically suggests: Let's make life very very very hard for a few JS API teams, in return for all other builder teams having an easier time.\nThis is a worthwhile tradeoff, and is aligned with making Polkadot more accessible: As a novice Application developer, you are not thrown in the pitfalls of a multi-chain, asynchronous, XCM-riddled ecosystem.\n\n[!info] Projects like txwrapper and api-sidecar are, in some sense, the same thing, yet since they are not vertically integrated into polkadot-sdk and/or PAPI/PJS, I am not sure if they get the attention they deserve.\n\nInstead, you have the option to start with the &quot;Polkadot Network API&quot;, and then graduate into using low level APIs that let you deal with chains and pallets from the get go.\nThat being said, one major technique that can be used while building this infrastructure to prevent it from becoming a maintenance snowball: Using RuntimeAPIs. That is, refraining from reading the direct pallet storage for as much as possible, and instead rely on more high level queries that the runtime exposes in the form of raw runtime-apis and/or view-function[1].\nThis moves at least a part of the complexity of implementing the above into the runtime, which has a few advantages:\n\nIt is the responsibility of the polkadot-sdk maintainers to update them, not you. Of course, these APIs are meant to have a super stable interface, and only their implementation might change.\nIt remains backwards compatible and upgrade-able by nature: If the :code changes, the implementation might changes.\n\nWasm view functions - Tech Talk - Polkadot Forum ‚Ü©Ô∏é",
		"tags": [ "note","polkadot"]
},

{
		"title": "On Documenting polkadot-sdk",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/on-documenting-polkadot-sdk/",
		"content": "I have been trying to improve polkadot-sdk's documentation for more than a year now. It has been a difficult journey, and admittedly beyond what I and a handful of others can reasonably solve.\nAs a lot of teams are applying to solve the same problems through governance and/or Decentralized Futures, I am sharing my <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/on-documenting-polkadot-sdk/#retrospective\">retrospective</a> of a year+ of working on this. I will also share how I believe teams getting funding will be most effective in working on this:.\nTo a large extent, I am wrapping up my contributions to this effort. My intention in writing this is to ensure all of my thoughts around it are publicly available, should they be useful to anyone in posterity. All of this is my personal opinion, and not Parity's.\n\n[!Info] Generally, when I refer to polkadot-sdk here, I mean a subset of the tools in Polkadot SDK that one needs to build a meaningful and useful application on Polkadot. That is, at the minimum: FRAME, Substrate, XCM and some offchain library to build a UI. A high level understanding of <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-s-build-horizon/\">Polkadot itself</a> is also needed. In summary:\n\nflowchart\n\tpolkadot[Polkadot as a Platform] --> polkadot_sdk\n\tpolkadot_sdk --> onchain\n\tpolkadot_sdk --> offchain\n\tonchain --> substrate\n\tonchain --> frame\n\tonchain --> xcm\n\toffchain --> subxt\n\toffchain --> PAPI\n\toffchain --> PJS-APIRetrospective\nThe Bad\nI will start by acknowledging that explaining polkadot[/-sdk] is hard. This is what I learned both from doing async documentation, and participating as a teacher in the Polkadot Blockchain Academy.\n\nFirst, there is a lot of Web3 background knowledge that needs to be explained, or assumed. More troublesome, Polkadot itself is a unique Web3 system, and has lots of novel concepts: Origins, Extrinsic, Runtime, Runtime API, Forkless Runtime upgrades and its implications, Host Functions, Metadata, Dispatch, Core (Polkadot Core), Parachain. I am not even opening the jar of all XCM related concepts here.\nRust is a difficult language, and the intricate way we decided to use it does not help.\nMoreover, the space moves fast. Look at the material around polkadot-sdk 2 years ago. A lot of it is less and less relevant today. Heck, even the name polkadot-sdk was not around, we are still in the process of re-establishing polkadot-sdk as a replacement of substrate[1].\n\nThe Good\n\nThe third issue is in general being solved by making Polkadot more stable as a whole. This is a strong promise that we hear from Parity and the fellowship: For our developers, we will make Polkadot stable, and stable for a long time. This also means less changes in polkadot-sdk, and therefore increasing the longevity of all educational material that is henceforth created.\n\n[!info] It is worth emphasizing here that this increased longevity applies to (new) content that is already correct and up-to-date.\n\nThe second is not solve-able by us per se, as we are not the creators of Rust and cannot reverse the decision to use Rust. But, some of the great steps we have taken to improve this include:\n\npba-qualifier-exam being open-source from the get-go.\nRust state-machine tutorial from @shawntabrizi, exactly created to improve this situation.\nTrait based programming guide for FRAME developers.\n(more ideas here, to be published later[2])\n\nThe first issue is mainly what I have tried to solve in the last year. I believe a lot of educational content in the Polkadot space feels incoherent, because it lacks solid foundation. As in, there is a lot of common foundational knowledge, that many educators have to either:\n\nRe-explain in their own words, risking fragmentation, or being poorly explained.\nSkip, and assume the reader already knows it.\n\n[!example] I have demonstrated an example of this here.\n\nWith this hypothesis, I believe there are two tools future educators can use to help with this:\n\npolkadot-sdk-docs: A strong foundation of API docs, references on foundational topics, and examples that are guaranteed to be always correct (because they live in polkadot-sdk repository and are always compiled as a part of its CI). Some of the FAQ that might be asked about this crate is covered in:\n\nWhy Rust Docs?\nScope\nPrinciples\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2024/polkadot-blockchain-academy-hong-kong/\">Recordings from the Polkadot Blockchain Academy</a>. I hope to see the latest Singapore edition be out soon (as the XCM module has undergone significant changes), but for now the Hong Kong recordings are an excellent resource.\n\nThe Future\n\nthere are still a number of core topics around polkadot-sdk for which I am personally not content with the degree of written documentation, and I intend to provide those as soon as I can:\n\nHow accounts are stored and behave in frame-system\nBenchmarking and Weights\nFees: Why they exist, under which conditions one can be exempted, and what tools FRAME provides for this. This should include the new feeless_if macro, and incorporate new personhood ideas presented by Gavin in Polkadot Decoded 2024[3].\n\nExplore converting this body of information to a markdown version for better readability and search and aesthetics. Possibly branded as a &quot;Mastering Polkadot SDK book&quot;.\n\nWishlist\nThis is how I think teams applying for funding regarding documentation will be most impactful.\nForward-Looking\n\nI wish to see more content created around the latest topics in Polkadot, rather than rehashing existing ones. Of course, a large part of the old materials that we currently have are still relevant, but they should be carefully handpicked and vetted. The topics of the year that are exciting to me are:\n\nIt is going to be all about Agile-coretime going forward, especially on-demand. A number of great tutorials should start with writing a pallet, adding it to a parachain-ready template, and end with acquiring one on-demand block on Paseo, and producing a block. This guide by Bader from Web3 Foundation is along these lines.\nUse of new developer tooling that simplify Developer Experience: Tanssi, PoP, Chopsticks, etc.[4]\nOZ Templates\nOmniNode\nUmbrella crates\nThe above 3 imply we can massively simplify our templates to\n\nUse the umbrella crates instead of dozens of them\nUse omni-nodes, and be mere Runtime Templates, removing the entire /node directory.\n\nTransaction/Signed Extension, and other features that are unique to what you can do a blockchain, and you cannot do in a smart contract environment.\n\nWhere contracts fail, and runtimes/chains are needed - Ecosystem - Polkadot Forum\npolkadot_sdk_docs::reference_docs::runtime_vs_smart_contract - Rust\n\nPersonhood.\n\nAll in all, I suggest educators to focus on creating tutorials on forward-looking topics, even if it means producing less.\nYou might argue that a lot of this is pretty advanced, and hard to grasp for those who are outside the circle of core contributors of polkadot-sdk, and you are right about that. And this brings me to the next point.\nExpect Better\nExpect better from core devs of polkadot-sdk. Foundational knowledge that explains the basics of an API and how it is intended to be used is not a nice-to-have, but a must. Core developers should provide the foundation for educators and technical writers in the space to create new content about the latest features. I hope to see most of this low level documentation to live in polkadot-sdk-docs.\nFinally, to make this process fruitful, you, as educators, build on top of the core documentation and backlink to it. This creates a strong mutual incentive for both parties to benefit from one another and maintain provide their share of the work. More specifically, I would imagine that polkadot-sdk maintainers will be more and more encouraged to provide foundational API documentation, if they know these are often used.\nBuild on the shoulder of giants, as the saying goes.\nAwesome Lists\nThere are so many cool developer tools out there, yet I am surprised to not often find them. I think the best way to aggregate these are indeed a standard awesome-list. We have an old one that is no longer maintained by Parity, and a new community driven awesome-dot. I hope to see a consolidation of the two into awesome-polkadot, with a dedicated maintainer.\n\nI am of the opinion that we should stop using &quot;Substrate&quot; as a keyword, and use &quot;Polkadot SDK&quot; as much as possible instead. Substrate should not be used as a standalone term, and instead it is a part of Polkadot SDK. ‚Ü©Ô∏é\n\nI am most excited about exploring the idea of opinionated frame_system variants. As in, FRAME is not frame_system. A runtime can be written with FRAME, and not use frame_system. An opinionated frame_system can be one that is 1. has more assumptions, and already encompasses multiple pallets in it, such as timestamp 2. has fewer generics, and more types hard-coded. ‚Ü©Ô∏é\n\nExplaining the typical example of allowing free transactions if one has a valid personhood certificate. ‚Ü©Ô∏é\n\nI am sure more exists, yet I am not familiar with them, see <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/on-documenting-polkadot-sdk/#awesome-lists\">Awesome Lists</a>. ‚Ü©Ô∏é",
		"tags": [ "note","polkadot","polkadot-sdk"]
},

{
		"title": "Polkadot SDK 2024 Roundup",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/polkadot-sdk-2024/",
		"content": "As we close the year 2024, and we have seen great roundup articles from the Polkadot ecosystem, I would like to have the honor to present some of the great work that has been done by the maintainers of polkadot-sdk in 2024. Other noteworthy roundups:\n\nPolkadot roundup by Gavin Wood\nPolkadot data roundup by DotLake\n\n[!info] Summary\nThis is a written superset of what I have presented in Sub0 Reset Bangkok in November 2024. See <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/frame-2024/\">Polkadot-SDK FRAME @ 2024</a>.\n\nPrelude: substrate To polkadot-sdk\nSubstrate\nThe original Polkadot white-paper named 5 key shortcomings in 2016 around the contemporary technology stack of blockchains, one of which is:\n\nDevelopability: How well do the tools work? Do the APIs address the developers‚Äô needs? Are educational materials available? Are the right integrations there?\n\nLooking at the direction take by Polkadot within the past (nearly decade), we can see a clear trace of this goal being prioritized by the Polkadot developer community.\nThis goal primarily manifested as the inception of substrate in 2018 as an independent brand next to Polkadot. Substrate was, and still is, a generic, modular and extensible blockchain framework that borrows some technical decisions form the needs of Polkadot, yet can be used independent of Polkadot[1]. It is used and loved by many developers, has collected more than 18,000 stars on GitHub[2] and has a sizable community in StackExchange. When looking at the position of Polkadot as the 3rd largest developer community in the recent Electric Capital Developer Report, most of these developers are in fact Substrate developers.\nSubstrate was eventually used to build Polkadot Relay Chain, and with the help of a neighboring framework, cumulus, it enabled any Substrate chain to become a Polkadot Parachain. Needless to say, many Polkadot-independent blockchains have also been built with Substrate, such as within the Cardano Partner Chains, Midnight, Avail or BitTensor to name a few[3].\nPolkadot-SDK\nIn May 2023, substrate, cumulus, xcm, and a few other key infrastructure technologies of Polkadot migrated to a new mono-repo called polkadot-sdk. This migration had multiple driving factors, that we can set aside for the sake of time. Yet, it marked an important transition to give more emphasis to the fact that Substrate is a part of polkadot-sdk.\n\nWhat matters today is:\n\nSubstrate as a technology framework remains, with exactly the same motivations and key features as before, which made many decision-makers decide to build on top of it[4].\nSubstrate as a brand is under the umbrella of Polkadot-SDK.\n\nThis has manifested itself in a few places worthy of noting:\n\nsubstrate.io, Substrate's branding website, and docs.substrate.io, substrate's documentation website both havebanners about this transition, and are intended to be fully moved to polkadot.com/sdk and docs.polkadot.com respectively, further centralizing the resources for Polkadot developers.\nThe main substrate template, formerly known as substrate-node-template is now called polkadot-sdk-solochain-template (and the counterpart, polkadot-sdk-parachain-template), emphasizing that this is a solo-blockchain, powered by Substrate, part of Polkadot-SDK, but not a Polkadot Parachain. This is further explained in <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-sdk-2024/#templates\">#Templates</a> section below.\n\n[!tip] Substrate or Polkadot-SDK\nWhile some discussion has happened around it, the Polkadot community has not, to the best of my knowledge, decided to fully stop using the word/brand Substrate. To name one example, conferences like Sub0 are curated around technological interoperability of Polkadot with the rest of the blockchain space, and Substrate is a key part of this narrative.\nThat being said, I personally prefer to always use the phrase &quot;Substrate, part of Polkadot-SDK&quot; to appeal to both of our goals. This is also aligned with the Wish For Change Proposal #1350, emphasizing the use of the work &quot;Polkadot&quot; in related technologies.\n\nSo, to summarize, Substrate is a part of Polkadot-SDK now, and as a technology framework, remains as-is. It has served builders within and outside of Polkadot, and continues to do so, with only a slight change in the name.\nWith this intro setting the foundation of our history thus far, let's look at some of the most major improvements to polkadot-sdk that have landed in 2024.\ndocs.polkadot.com\nLittle needs to be added here by me, as the recent article in Polkadot.com says it all: After a few years of scattered documentation (which admittedly was partly the consequence of transition from substrate to polkadot-sdk), Polkadot now has a brand new documentation portal, hosted right at the official website, which also covers numerous polkadot-sdk-related products, such as launching your own Parachain.\n\ndocs.polkadot.com has only seen its initial release in December 2024, so a lot of further improvements are expected to land in 2025. That being said, we can confidently assert: docs.polkadot.com will be the single source of truth for documentation around Polkadot going forward, and all new features will be documented here.\nStable Releases\n\nSome of us were around for long enough to remember the early days where building on Substrate entailed using git dependencies in Cargo.toml[5].\nA bit later, polkadot-sdk crates were being published to crates.io, yet without proper semantic versioning and with a system that I like to call YOLO-MAJOR-BUMP-EVERYTHING. This meant that updating one dependency always entailed updating all dependencies, and was a particularly good experience for developers either.\nThose days are well passed us now, thanks to the stable and semver-aware release schedule of (everything in) polkadot-sdk.\nToday, all crates in polkadot-sdk get a new release every quarter (named stable-YYYYMM, for example the last one being stable-202412), all crate versions are updated based on exact changes that have happened since the last release[6], and each stable release will receive bug and security fixes for a full year.\nThe emergent benefits of this can be broken down into:\n\nAt any given stable-YYYYMM release, you are free to avoid dealing with upgrades for a maximum of one year. Further delays might mean missing out on security fixes.\nYou will have more freedom in mixing and matching different high level crates at different versions, such as FRAME Pallets.\n\nTo learn more about the release process, see RELEASE.md, and the paritytech/release-registry.\n‚òÇÔ∏è Umbrella Crates\nToday, Polkadot-SDK, when not used with umbrella crates, is an aggregate of more than 500 crates. When starting with any of our (pre-umbrella) templates, one typically would work with 80 crates to maintain the node software, and around 50 crates to maintain their runtime and a set of custom pallets[7]. This degree of modularity is useful for power user, yet a hinderance to new joiners. Moreover, dealing with a larger number of crates also means more complicated dependency upgrades, as noted above.\nIn 2024, Polkadot-SDK saw two new crates which we like to call umbrella crates:\n\npolkadot-sdk\npolkadot-sdk-frame (which we would have wished to just call frame, but this name is taken by a crate sniper as of 6 years ago)\n\nThese crates are crafted to abstract away the immense size and modularity of Polkadot-SDK away from new joiners, in return for less control over exact versions. Let's see how each of them work one by one.\npolkadot-sdk\nThis is the umbrella crate that is mainly meant to simplify your Cargo.toml. Both in the node and runtime component, instead of dealing with all the low level sc-* and sp-* crates, you can use the single polkadot-sdk crate. This crate will then automatically pull all of the relevant dependencies based on the feature flags.\n\npolkadot-sdk-frame\nThis is the umbrella crate that is mainly meant to simplify your .rs files within FRAME pallets and runtimes. It is a wrapper around all of the common type, trait and functions that are often used within a typical FRAME pallet.\nInspired by our very own ink! and its appreciated preludes, it aims to provide a single prelude that you can import for composing your pallets and runtime.\nuse polkadot_sdk_frame as frame;\n#[frame::pallet]\npub mod pallet {\n\tuse frame::prelude::*;\n\t// ^^ using the prelude!\n}\n\n#[cfg(test)]\npub mod tests {\n\tuse frame::testing_prelude::*;\n}\n\n#[cfg(feature = &quot;runtime-benchmarks&quot;)]\npub mod benchmarking {\n\tuse frame::benchmarking::prelude::*;\n}\n\npub mod runtime {\n\tuse frame::runtime::prelude::*;\n}\n\nAt the time of writing, polkadot-sdk-frame is still in the process of being integrated into polkadot-sdk's pallets and templates, and once done it can be marked as &quot;stable&quot;. You can track the progress of this effort in [tracking] Migrate pallets to umbrella crate ¬∑ Issue #6504 ¬∑ paritytech/polkadot-sdk, which has been a great avenue for external and fellowship members to contribute to polkadot-sdk.\nIndeed, polkadot-sdk-frame is part of the parent polakdot-sdk umbrella crate as well.\npolkadot-omni-node\nTaking a step further in the same direction, another realization is that most parachain teams prefer to not even maintain their node, as they do not customize anything in particular with it. This is where polkadot-omni-node steps in: a single binary, now available as a part of stable-202412 for both Linux and Mac, that can run the runtime of most parachain.\nThis essentially allows a parachain team to reduce their code maintenance footprint into just maintaining a runtime, the output of which would be a runtime.wasm or a chainspec.json file, which can be fed into polkadot-omni-node binary both for local development, and for production deployment.\nTemplates\nSpeaking of templates, it is worth noting that polkadot-sdk now has a set of 3 un-opinionated templates, replacing the older and unmaintained ones. These templates are maintained in polkadot-sdk/templates folder, and are automatically synchronized to their corresponding external templates upon each stable-YYYYMM release:\n\nparitytech/polkadot-sdk-minimal-template: The Minimal (Testing/Learning-Only) Template From Polkadot SDK\nparitytech/polkadot-sdk-solochain-template: The Solochain-Ready Template From Polkadot SDK\nparitytech/polkadot-sdk-parachain-template: The Parachain-Ready Template From Polkadot SDK\n\ndocs.rs\nMoving on to more low level details, you may have noticed that a lot of the above topics, which are new concepts, are backed by links to Rust's API documentation toolkit, docs.rs. Throughout 2024, we have identified that:\n\nAll of the high level documentation of Polkadot-SDK should be centralized in a single source, which ended up being <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-sdk-2024/#docs-polkadot-com\">#docs.polkadot.com</a>\nPolkadot-SDK, like any other mature Rust framework, should maintain its own API documentation in docs.rs\n\nThese API docs are important, as they serve to sit a different audience compared to <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/polkadot-sdk-2024/#docs-polkadot-com\">#docs.polkadot.com</a>: They are the source of truth for day to day troubleshooting, and in the presence of an IDE, provide instant information that can be used by developers[8].\nOne notable example of this is FRAME macros. Today, they all have extensive API documentation which you can access directly in your IDE, or from docs.rs:\n\nAll of the released docs are present in docs.rs (like this or this) with proper versioning, and the master version is deployed on every commit to polkadot-sdk under parity paritytech.github.io/polkadot-sdk/master/.\n... And What About Smart Contracts???\nAll of the above is improvements to the original product of Polkadot-SDK, the Parachain/Solochain. While all of the above is a testimony to this product becoming simpler to build, it is worth noting that Polkadot will soon have a brand new product, being developed under the project codename Plaza/Hub, which will allow Solidity smart contracts to be directly deployed to Polkadot.\nThe important point is that Solidity contracts will inevitably be simpler than building a Parachain, no matter what. This features is planned for deployment by Q2-2025 on Kusama, and by Q42025 on Polkadot. The preliminary documentation for the demo version on the Westend test network is available in Intro | Contracts.\nAcknowledgment\nWhile I am the messenger of all of the above features, delivering the above is mainly the work of numerous other Parity engineers and Polkadot fellows, which I will name as there will be too many of them.\n\nSee this PBA Lecture from Hong Kong cohort on Substrate, or the slide deck here. ‚Ü©Ô∏é\n\n8.4k in substrate, 614 in cumulus, 7.1k in polkadot, and finally 2.1k in polkadot-sdk, the sum of all the repost that Substrate developers have worked with. ‚Ü©Ô∏é\n\nSee here or here for further list of non-Parachain Substrate chains. ‚Ü©Ô∏é\n\nSee this reference about the exact position of substrate within polkadot-sdk. ‚Ü©Ô∏é\n\nThis was mainly due the fast development pace of Substrate and Polkadot SDK, and the sheer size of the repository, making it exceedingly difficult to have stable releases. As of now, polkadot-sdk is around 1.8 million lines of rust code, scattered in more than 4000 files, based on on a recent cloc run. ‚Ü©Ô∏é\n\nThose who contribute to polkadot-sdk via PRs are asked to provide a prdoc that encapsulates all changes to crates and respective version bumps, example. ‚Ü©Ô∏é\n\nNumbers are estimated based on an old commit of the polkadot-sdk-parachain-template's node and runtime Cargo.toml. ‚Ü©Ô∏é\n\nNot to mention they act as great learning material for LLMs. ‚Ü©Ô∏é",
		"tags": ["Templates", "1350", "6504", "note"]
},

{
		"title": "Polkadot's Build Horizon",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/polkadot-s-build-horizon/",
		"content": "This write-up explains what Polkadot is at 4+1 different levels for Builders, in a color coded fashion:\n\nPolkadot, the platform itself\nOnchain Development: Runtime/Parachain/Task development\nOnchain Development: Smart Contract\nMessaging between the previous components\n(+1) Off-chain applications talking to any of the above items.\n\nFor each item, I have listed what I believe to be the best ‚Äúeducational resource‚Äù on the topic now or in the near future. This is by no means exhaustive, and I encourage readers to comment what else they can think of.\n\nI generally refrain from referencing docs.substrate.io as it is not a well maintained resource. I am working, and hope to see a smaller but more accurate replacement for this website, such as polkadot-sdk-docs\n\n1. Polkadot, the Platform\nFirst, what is Polkadot itself, as a platform? A ubiquitous computer/blockchain that is\n\nMulticore, as in, it has heterogeneous sharded execution. Each shard/core can execute a different task.\nProvides a homogenous layer of shared security over all the cores and all the tasks that run on these cores.\nSo far, the only type of task explored has been what we call a &quot;para-chain&quot;, but going forward, we expect to see diverse type of tasks being deployed on Polkadot.\nSo far, the only way to acquire execution time on a core (i.e. &quot;core-time&quot;) has been to win a parachain auction, but soon, with agile core-time, acquiring core-time will become much easier and granular.\n\nResources\n\nhttps://education.web3.foundation/docs/introblock\nhttps://education.web3.foundation/docs/introdot\nhttps://spec.polkadot.network/\nhttps://wiki.polkadot.network/\n\n2. Onchain Development ‚Äì Runtime / Task\nRuntimes are the primary type of tasks that can run on Polkadot cores. They are expressed as WASM blobs. They are scheduled anywhere between one block at a time (formerly known as on-demand parachain, or parathreads) to 2 years (formerly known as a parachain) to anywhere in between (agile-coretime). Commonly built with FRAME, and typically representing a blockchain application logic. But, crucially, a runtime can also represent any other application.\nResources\n\nPolkadot SDK | Substrate_ Docs\npolkadot-sdk-docs\n\ntemplates\n\nIntroduction to Polkadot SDK - Substrate &amp; FRAME | Polkadot Education Initiative\nParachain Development Guide | Polkadot Education Initiative\n\n3. Onchain Development ‚Äì Smart Contracts\nA task/runtime that run on a Polkadot core can itself be what is known as a smart contract platform, similar to Ethereum or Solana, examples of which are Moonbeam and Astar. These platforms could support multiple virtual machines such as EVM and WASM, or both.\nTherefore, Polkadot supports smart contract development as a secondary feature through its evolving ecosystem of parachains.¬†There have also been discussions/proposals on a native smart contract platform for Polkadot, but none has existed so far.\nMoreover, a team can utilize the above technology to deploy what is known as &quot;single dApp chain&quot;. Imagine a contract is successful in a shared environment, such as Moonbeam, and now wants to have more bandwidth and lower fees. This can be achieved by a runtime, written with FRAME, that can execute smart contracts, and only hosts the contracts of this one team. Then, some contracts can be rewritten as FRAME modules, enabling more bandwidth and low-level features. Finally, the contract can graduate to a full FRAME runtime.¬†More on this in the recap figure down below.\nResources\n\nhttps://use.ink/\nFrontier docs\nFrontier-parachain-template\n\n4. Onchain Development ‚Äì Interoperability and Message Passing\nBecause of Polkadot‚Äôs shared security, Runtimes and Smart Contracts (or any other task that resides on a core) can communicate with one another without a need to worry about the economic security of the recipient of the message. Any message can be sent between cores, yet the primary language adopted in the ecosystem is XCM, short for Cross Consensus Message.\n\nXCM-docs\n\n5. Offchain Development\nPolkadot ecosystem comes with a slew of APIs to write decentralized[1] applications that are based on the previous primitives. These programming APIs will allow developers to connect to and interact with a runtime, a smart contract, or both.\nResources\n\nRust: Sub-xt\nJS/TS: Polkadot-JS-API\nJS/TS: Substrate Connect\nSubstrate frontend template\nPolkadot Cloud Library / Polkadot UI Library\npy-substrate-interface\nFull list of client libraries\n\nRecap\nThe following figure shows all the aforementioned development types:\n\nPolkadot, the platform itself\nOnchain Development: Runtime/Parachain/Task development\nOnchain Development: Smart Contract\nMessaging between the previous components\n\nAll cores in this figure are being used for bulk coretime, except Core 3 which is meant to represent instantaneous coretime.\nT1 and T2 are two runtimes sharing a core. This represents a broad category of scheduling where they take turns, uses a secondary market, or anything else.\n\nSee RFC#1 for more examples.\n\nT3 is a long-running Runtime, using bulk coretime.\nT4 is a generic smart contract platform like Moonbeam. Your application can be one or many of the contracts running on T4.\nT5 is a proprietary smart contract platform aka. ‚Äúsingle dApp chain‚Äù, where you have pallet-contracts, a number of contracts, and a number of (custom) FRAME pallets all baked into a single runtime. This runtime can initially be scheduled sporadically, as is the case with T5.\nT6 is the same as T5, but scheduled on a dedicated core, as opposed to on-demand.\n\nSo, for example, imagine the following user journey for a business on Polkadot: You start as a set of contracts running on an existing parachain. You expand into T5, a &quot;Single-dApp Chain&quot; where you can have both contracts, and pallets. Once the demand ramps up, T5 evolves to T6, meaning you use more bandwidth. Finally, one could eliminate all contracts and use only pallets for their application logic, such that they can leverage control over the runtime maximally, such as T3.\n\nAny communication within one Runtime (so long as you remain in one green box) is synchronous. Anything that wants to cross the boundaries of the green box is asynchronous. Any two components in this figure can talk to each other, but if it is asynchronous, it could use XCM.\n\nThis is a good moment to reflect: a lot of the complexity in XCM is exactly because it is designed to deal with asynchronous communication across consensus systems.\n\nTechnically, any communication within one core can be synchronous, but this is not how it is implemented now. In principle, two parachains that are co-scheduled on a single core (T1 and T2) can also have synchronous communication.\nFinally, T7 is representing an application that is utilizing two Polkadot cores at the same time. This essentially allows a runtime to move at very fast block times. This is enabled by what is known as &quot;async-backing&quot;. Moreover, Polkadot could allow tasks to increase and reduce their bandwidth on the fly. This is called &quot;elastic scaling&quot;.\n\nMiscellaneous Resources\n\nhttps://education.web3.foundation/docs/introrust\nhttps://polkadot-blockchain-academy.github.io/pba-book/frame/index.html\nhttps://github.com/Awsmdot/awesome-dot\nhttps://github.com/shawntabrizi/rust-state-machine\nhttps://dotcodeschool.com/\nhttps://www.youtube.com/@polkadotblockchainacademy/playlists\n\ndecentralized: Polkadot comes with a light-client-first application development mindset, which means applications written with the following tools can connect to light clients (instead of centralized API providers) and actually be decentralized. ‚Ü©Ô∏é",
		"tags": [ "note","polkadot"]
},

{
		"title": "Sharded and Non-Sharded TPS in Blockchains",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/sharded-and-non-sharded-tps-in-blockchains/",
		"content": "Originally posted in x.com.\n\nThe argument of a sharded and non-sharded TPS differing is valid. But the answer is not as simple as @Justin_Bons's &quot;any sharded system can achieve millions TPS&quot;.\nFirst, what is valid about it: When you evaluate a CPU, you ofc look at both single core and multi-core performance.\nThen, you look at the quality of the sharding:\n\nIs each shard's isolated progress secure?\nHow fast shards can communicate with one another?\nBecause we are in Web3, the security of this communication is also important. Are messages final? Can the sender and recipient trust one another?\n\nWhat often gets lost in translation is that Polkadot's sharded architecture achieves 5/6 figure TPS with all the 3 above criteria uncompromised.\nMost, if not all, of the &quot;1m TPS sharded systems&quot; are butchering those 3 criteria to increase TPS, while @polkadot decided not to, and this is why it is different.\n@rphmeier put it best that TPS is not just a quantitative measure, it also has qualitative. And when comparing TPS, sharded or non-sharded, it should be taken into account.\nThe assertion then is: Polkadot has the best combination of abundant, and high quality blockspace/TPS, because it doesn't compromise on the above criteria.\nLast but not least, everything said above is the existing Polkadot architecture, which Ethereum and others are converging into.\nJAM upgrade is a realization that even @Polkadot's uncompromising solution to sharding is not enough -- we also need flexible boundaries among shards, allowing them to synchronously compose, should they wish to communicate.\nThis novel property is phrased as semi-coherence in the title of the graypaper.com: A system that is coherent (synchronous) for a subset of shards/rollups/contracts that often communicate, and incoherent (asychronous) for others.\nThis adds a 4th qualify to our list of qualitative metrics for blockspace, and Polkadot, through JA upgrade, is the sole project inventing its way into providing it.",
		"tags": [ "note"]
},

{
		"title": "The 10x Developer Myth: All About Keyboard",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/the-10x-developer-myth-all-about-keyboard/",
		"content": "Theory\nRecently, I engaged in a few discussions about optimal use of editors and keyboard shortcuts with new team members. It eventually inspired me to write this short article, asserting that this &quot;10x developer&quot; idea is for the most part about keyboard shortcuts.\nIn other words, while I think developers also vary in terms of how they think about problems, and their cognitive abilities, 90% of the time, the ones that stood out among others, and are perceived as much as 10 time more &quot;productive&quot;, are simply better at the craft. And I think 99% of the craft of programming revolves around the relationship between you and your keyboard.\nI am already expressing my first thesis implicitly. Keyboard. Not your mouse, not your trackpad. Keyboard. Those are inefficient alternatives put there for the times where the programmer fails to use the keyboard (I use my trackpad often, like most others, sadly).\nAs I will demonstrate later, every instance where you use the trackpad, you are already losing a little bit of time. So, focus on learning more about how to efficiently use your keyboard, rather than dragging things out with your mouse.\nA little story about how I came to be so dogmatic about this: The first laptop I had as a programmer was this piece of history, and for whatever reason I didn't have an external mouse. The trackpad on these machines is a joke. It is so small that you barely can move it from one corner of the screen to the other. Instead of trying to fight it, I learned from a very early stage of my career as a programmer to hyper utilize the keyboard.\nOver time, this became a blessing. Nowadays, having had multiple generations of MacBooks, even though I appreciate the trackpad for other tasks and am happy to not need to brows my file system anymore using keyboard, I happily hold the same habit while I am coding and try to avoid the trackpad as much as I can.\nSecond, and main part of the thesis: In general, as a programmer, your attention is disrupted in generally one instance: when your hands over the keyboard fail to keep up what it in your mind's thinking. Let's consider this both when you are reading and writing code.\nIn writing, you want to be able to quickly prototype different approaches, and put words on the screen. Imagine you have to do a refactor, where, for example, you have to unwind a few loops and change their indentation real quick, duplicate a few lines etc. If you manage to do this almost as fast as your brain is unpacking it, while you are in the creative process, you can continue, and your attention is not disrupted. If you delay doing this for multiple minutes (probably your damn mouse, hitting copy and paste and moving the cursor with it) you have most probably lost the train of thought that led you to want to do in the first place.\nMoreover, I frequently see people find doing such code refactors as &quot;annoying&quot;, which is understandable because it is being done in a very poor way. This can sadly lead to a decline in general interest in programming as whole.\n\nIdeally, you want your hands on the keyboard to be so agile that even mundane refactors are actually fun to do, because you get to practice all the cool tricks you know.\n\nIn reading, I think this is even more visible. Imagine you want to follow a train of types and traits that relate to one another, trying to demystify them. If it takes you too long to jump from the file where you see the symbol Foo to where Foo is defined or used, then this process becomes mighty ANNOYING, and again can be demotivating to experience, other than being unproductive as well. And this is assuming you know where Foo is defined. If not, you have two tasks at hand: where is Foo (which is mostly solved for you if you have a language server), and how can I get there in the most efficient way (and the most efficient way never involves using a trackpad, it should be a single shortcut).\nThis is where my whole rant about not using the mouse is coming from. I think if you are really bad in the above, there is a long way that you can go while using a mouse. But sooner or later, you will reach a point where you realize that point of &quot;losing the attention&quot; is every time your hands must leave the keyboard, because you want to perform an action that you cannot do while your hands are already on the keyboard.\nSo all in all, in theory: you want your hands, on the keyboard, to be able to keep up with your head while it is thinking. This is the main message, and how you achieve can vary.\nBut the important point is to keep improving. Every time you face that annoying moment of not being able to do something easily, go to Google, and the documentation of whatever editor you are using, and see if/how you can improve this. Don't cope with such micro-inefficiencies, as they accumulate over time. To the contrary, once you start fixing them, you will learn your editor in much greater depth, which has a compounding positive effect.\nYour editor is of choice is very important here. It is like the brush to the painter. Make sure you become a strong fanboy of it by following all the releases, seeing what is new etc.\nWith all of that, I will list some of the settings, configurations, and shortcuts that help me achieve the above.\nPractice\nThe assumption here is that like most programmers, you have a few desktops, in which you have separated at least 3 main tools: An editor, a terminal, and a browser (and perhaps more).\nOperating System Level\n\nThe absolute first step is master your cursor. The involves a few settings:\n\nIncreasing its speed significantly. The default cursor speed is way too slow.\nLearning how to jump by word rather than character.\nLearning how to jump the beginning and end of the line.\n\nLearning to move between the few desktops you have open via keyboard.\n\nIn my Linux days, the shortcut to move the active application to another desktop was rather easy, but is rather dodgy to setup in MacOs. I have mostly forgotten about this.\n\nLastly, you want to be able to easily split your screen into two, left and right. I personally find anything more than this to be an overkill, but most apps that allow you to do one allow you to do all of them, such as rectangle.\n\nThere's a lot more here, but I presume you can figure out what else can help you achieve the above principles better.\nEditor Level\nI personally use VSCode with Rust analyzer. But almost everything here should be applicable to any language and editor.\nFinding The Right File\nFirst, you want to be able to easily find the file that you are looking for. There are typically two ways to find a file:\n\nFind it by location in the sidebar, file-tree list thingy.\nFind it by name.\n\nThe find a file by its location, you want a keyboard shortcut that can quickly move the focus of your editor from the code you are editing to the the file-tree (remember, no touching the damn mouse for any of this!).\n\nThe keyboard shortcut config name for this is &quot;View: Show Explorer&quot; in Vscode.\nSometimes, you have the file that is already of interest open in a different tab, and you know that tab is nearby. For this, you need a shortcut to move to the next/previous tab real quick.\n\nI personally end up having a million tabs open at all times. Sometimes I happily disable tabbing with Vscode zen mode and call it a day. The two ways mentioned above are good enough to find any file quickly.\n\nIf you use the integrated terminal in vscode (I don't) you probably want shortcuts to switch focus to/from it as well.\n\nIf you want to use a file by location, the way to do it is the fuzzy finder. I don't know what editor you use, but it must have a fuzzy finder. A fuzzy finder is one that more or less does it best to match the string you are inserting to anything in the path of the final file. For example, if you are looking for a file that is located in /foo/bar/prettyUniquePart/src/mod.rs it is not wise to try and find it in the fuzzy finder with the mod.rs part, but rather inserting pretty might be enough.\n\nThe fuzzy search can be opened by VScode using cmd+p by default, and it can do a lot more than fuzzy search!\nNavigating The Right File.\nNow, assuming you are the master of opening files, you want to be able to navigate it in a skillful way.\nFirst, you want to have ways to scroll the file real quick. Similar to the cursor speed, where the default speed is super super slow, the default scroll speed might also be very slow. You want to know the keyboard shortcuts that let you:\n\nJump a page up or down (shortcut name: cursorPageDown).\nJump to end and beginning of the file (shortcut name: cursorBottom).\n\nAs a backup, should you fail and need to use your trackpad, VSCode can be configured to have a fast-scroll next to the normal scroll, which is pretty useful.\n\nThen, you want to be able to find some symbols. If you have a language server, you will get a lot of information related to this in your screen already, but there's still a few tips to be added.\nFirstly, if you have a proper language server, you better be apt at using it. This involves knowing the keyboard shortcut for super useful operations such as: &quot;Jump To Definition&quot;, &quot;Peek Definition&quot;, &quot;Find References&quot; and such.\n\nThen, two additions to the fuzzy search cmd+p. If you open the same, and prefix it with @, then it turns into a local symbol search. If you prefix it with # it turns into a global symbol search (might not work on large projects). If you prefix it with : it will help you jump to a file with a specific line number.\n\nLastly, if you put &gt; it will allow you to execute internal commands, such as &quot;format document&quot; etc.\n\nThere is also a fuzzy (or more intelligent) suggestion shortcut in most editors, that you can just use to ask for suggestions from the editor. The shortcut for this mostly involves something with space (cmd+space) and is called &quot;Trigger Suggest&quot; in Vscode.\n\nWith or without Rust analyzer, I have a few regex-based custom commands that I find vastly useful in large Rust Mono-repos, to find symbols quickly.\n\nThen, let's talk about the (much underrated) cmf+f and cmf+shift+f. You know what they do: they invoke local file search, and global search. They are okay as they are, but what are you going to do with the results, without needing to use the cursed mouse? that's right, you need shortcuts to navigate the results. This is really powerful, and turns these mundane shortcuts into super tools.\n\nThe keyboard shortcut for these is called &quot;Find Next/Previous&quot;, &quot;Search: Focus Next/Previous Search Result&quot;.\nEditing The Right File.\nLastly, let's talk a bit about edit editing files. Writing code is mostly easy if you are only adding words. It mostly gets hard if you want to do bulk edits, or if you want to do more complicated things. Here are a few things that I find important, but my suggestions here are really non-exhaustive.\n\nindent/de-indent\n\nduplicate line\n\nmove line(s)\n\nsome knowledge of how to do multi-cursor operations.\n\nTerminal Level\nI won't get into details here because this has already gotten long, but be aware that you can also optimize your use of terminal by quite a lot as well. The single most useful thing I can suggest for coding is the ability to jump right from your editor into the file path where some error has occurred (sadly, using your trackpad). I believe ITerm2 and Vscode's internal terminal support this out of the box.\n\nAll in all, there's not much new that I am saying here. Most of these shortcuts and operations are already known. The main argument is: &quot;Use the keyboard!&quot; üòÖ.",
		"tags": [ "note"]
},

{
		"title": "Thoughts Blockchain and Blockspace Scalability",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/thoughts-blockchain-and-blockspace-scalability/",
		"content": "Originally published in the Polkadot forum.\n\nWhile thinking about a tutorial idea about FRAME, I came up with an interesting example that showcases/categorizes the scalability issue in blockchains, which is somewhat entangled with game theory. Here it goes.\nImagine a simple validator selection system whereby:\n\nanyone can call¬†bond(amount), which registers them as &quot;wanna-be validator' with¬†amount¬†as their approval-stake.\nanyone can call¬†delegate(who, amount), which increases the approval-stake of¬†who by amount.\nevery x blocks, we want to get the top¬†x¬†wanna-be validators based on their respective approval-stake (to the best of our abilities).\n\nThis is an extremely simple problem in the context of more information systems, but it is a surprisingly hard problem to solve in blockchains. Let's explore why.\nThe answer really boils down to one root issue: Blockchains, unlike all almost many other information systems, are not sybil-resistant. When you are thinking about solving the above algorithmic problem, you must assume you are solving it for an infinitely large input size. In this case, this translates to an infinitely large number of wanna-be validators.\nThe first step in solving such issues is acknowledging such issues, and finding the boundaries of where your system breaks. For the above example, assume that an analysis on weight, memory or state usage could help us conclude that the system would work for as long as there are less than V_max wanna-be validators registered in the system.\nIn essence, the problem can be stated as sybil-irresistance -&gt; scalability issues. In written words, blockchains are not sybil resistance, therefore face scalability issues.\nWe can tackle this issue in both sides of the above arrow.\nTo fix/improve the sybil-resistance part:\n\nCrypto-economics: This means, the deposit to become a wanna-be validator must be high enough such that the cost of registering V_max wanna-be validators is so high that no sane human/attacker would ever do it.\n\nPermissionless operations: The system is not sybil-resistant because it is permissionless and anyone can spam the system. But, that also means anyone can clean aka. de-spam the system üß†. In the above problem, imagine the chain would keep a linked-list of wanna-be validators, and allow anyone to submit an extrinsic that would swap two nodes in the list, as long as it is a positive step toward keeping it sorted. Crucially, if the extrinsic is successful, the submitter gets a (possibly small) reward, that could come from the deposit of the wanna-be validator that was misplaced.\nThis approach almost always goes hand-in-hand with crypto-economics, and would significantly lower the deposits needed to make sure V_max is never reached. For example, if we solely rely on crypto-economics, we probably have to impose a relatively hefty deposit to solve the above validator selection problem. But if we also rely on permissionless-operations, the deposit only needs to be high enough such that it is enough incentive for someone to submit those sorting extrinsics!\n\nOther Web3 primitives such as DiDs, PoPs and NFTs. There is a broad category of other primitives out there that, if themselves implemented correctly, can de-sybil the system. In our example, this translates to: making sure only accounts that have a particular identity, NFT, or personhood proof attached to them can become wanna-be validators. These systems could be enough to give you credible guarantees that V_max will not be reached.\n\nPolkadot's Staking system in fact implements a linked-list like above, you can read more about it here.\n\nNote that neither of these solutions attempt at really solving the scalability part. They don't help increase V_max. They merely help with making the system more sybil resistance, ie. knowing that V_max is (almost) never reached.\nOftentimes, you want both. You want to be somewhat more sybil resistant, but you also want to be more scalable. Imagine you have implemented some or all of the of the above, but simply want that V_max to be larger. This translates to &quot;more blockspace&quot; and typically there are two ways to improve it:\n\nBlockspace optimization. This is a realization that blockspace is a valuable scarce resource, and its usage can be avoided, if possible. Imagine, given input X and output A, a function F(x) -&gt; A and verifier function V(A) -&gt; bool which can verify the output to be correct. We have two options: run F onchain, which needs no verification because the code is trusted. Or else, run F(x) offchain, where none of these scalability issues exist, and submit A back to the chain, and run V(A) onchain. Depending on the complexity of F, V and the size of x and A, it might be the case that doing the latter is more efficient. This realization is the basis of the rollup space. Specifically, ZK-rollups fit the above description perfectly. I would leave it up to the reader to tinker on whether the above sorting problem can also leverage this optimization or not (and comment their thoughts).\nBlockspace scaling: Another solution is to simply leverage more blockspace, which one can do by writing operations that are multi-block. This also increases the maximum limit of V_max that is acceptable by the system, yet poses its own set of problems.\n\nRecall, all of this helps us achieve a higher V_max for the above problem, neither try and prevent spammers to fill the entire space of V_max.",
		"tags": [ "note","polkadot","blockchain"]
},

{
		"title": "Phragm√©n Overview",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/phragmen2/",
		"content": "Longer version of <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/phragmen/\">Phragm√©n for Polkadot's NPoS</a> at Substrate Seminar.",
		"tags": [ "note"]
},

{
		"title": "Phragm√©n for Polkadot's NPoS",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/phragmen/",
		"content": "",
		"tags": [ "note"]
},

{
		"title": "Substrate Debug Kit",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/substrate-debug-kit/",
		"content": "Longer version of <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/phragmen2/\">Phragm√©n Overview</a> and <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/phragmen/\">Phragm√©n for Polkadot's NPoS</a> at Substrate Seminar.",
		"tags": [ "note"]
},

{
		"title": "Polkadot's Nominated Proof of Stake",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/polkadot-npos/",
		"content": "..Past, Present, and the Future.",
		"tags": [ "note"]
},

{
		"title": "Nomination Pools",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/nomination-pools/",
		"content": "..and The Story of The Polkadot's NPoS at Polkadot Decoded 2022",
		"tags": [ "note"]
},

{
		"title": "Blockchain Scalability - A Holistic Recap",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/blockchain-reimagined/presentation-tum/",
		"content": ".reveal .slides section img {\n\tmax-height: 70vh; /* Limit image height to 70% of the viewport height */\n\twidth: auto; /* Maintain aspect ratio */\n\t border-bottom: 1px dashed rgba(0, 0, 0, 0.5);\n\t padding: 20px;\n}\n\nBlockchain Scalability\nA Holistic Recap\n\nPrelude\n\nHello üëãüèª @kianenigma / kianenigma.nl\nPolkadot for ~6 years\nRe-discover the fundamentals of blockchains\nI am here to solve industry-scale problems, not sell a product\n\nNotes:\n\nI am a core engineer of Polkadot.\nOn a journey to re-discover the fundamentals of blockchains. This talk is part of my journey.\n\nPurpose-dysphoria\n\nAcademic talk, not selling anything. Not talking much about Polkadot (very little)\n\nOwning Digital Money\n\n‚Ç¨1000 in Revolut (üî´üëÆüßë‚Äç‚öñÔ∏è‚õ™Ô∏è -&gt; Conditional Trust)\n‚Ç¨1000 in the Bitcoin network (üßÆ ‚ôæÔ∏è -&gt; Synthesizes Verifiable Trust)\nEconomically secured validators (üíªüí∞) doing redundant work\n\nNotes:\nWhy do we trust each?\n\nIn Revolut, there is, in principle, as little as one computer, owned by Revolut, processes a transaction, and we trust the outcome of that, because of all the legal regulations around banking, government, law enforcements etc.\nIn the bitcoin network, we synthesize a new type of trust, that is not based on social-norms, central-power, and law-enforcement, and is instead more based on branches of science, and is therefore verifiable, namely: mathematics, game theory and economics.\n\nWe don't trust a hash function to be one-way because a certain nation has a strong military, it is one way no matter who you are, and where you live.\n\nA big part of this &quot;based on branches science&quot; is the fact that in a network like Bitcoin:\n\na large number of actors can be the authority, each taking turn in become the leader\nand many others, can check what that leader has done\n\nWe call this collective of the above two groups of entities &quot;Validators&quot;\n\nAll validators have skin in the game -&gt; Economic Security\nAll other nodes can observe and re-verify the behavior of validators\n\nSecure Validator Set Working Together\n\nIs one massive, SLOW, TRUSTWORTHY computer.\nNotes:\n\nAnd a key reason why blockchains have a hard time scaling: All validator's at the simplest model, have to re-execute everyone else's work, and come to consensus/finality about it.\n\nQuestion: Which Computer model is good, or perhaps good for which use cases? idk, deeper philosophical question.\nQuestion statement: How can I make the Web3 Computer go faster? and while doing so, am I am compromising on the trust-worthy-ness of it?\nThis is the core issue we try to tackle, how can we remove this property of &quot;everyone re-executes everything&quot;.\n\nScaling Options\n\n+ No fragmentation\n- Vertical scaling / Cutting corners?\n\nNote:\n\nSomewhat like brute forcing it.\nNeeds careful consideration of how much of trust-worthiness of the original model it retains.\n\nNot having merklized state -&gt; no light clients ever\nHardware requirements to run the network beyond what an individual can ever afford.\n\nSolana - How it Works (Helius)\n\n- Sharding Security and Capital / Limited Capital\n\nNote:\n\nCosmos' original view\nThere's only limited capital in the world, shard execution, and economic security.\nMulti chains, in general real to a multitude of issues:\n\nüê¢ Slow and asynchronous communication\nüí¥ vs üí∞ / ü•∑: varying degrees of economic security, leading to a the weakest link issue\n\n- Slow finality / ‚ö†Ô∏è Need FP / Fragmented\n+ Little overhead on L1 (Execution, DA)\n\nNotes:\n\nlittle overhead on the base security layer, scales well:\n\nNew rollup, in the absence of fraud, no overhead on L1 in terms of execution, only DA\nAlthough, in the presence of fraud, the L1 has to re-execute everything. I wonder how much this scales in the presence of frauds, and when compared to the cost of performing fraud.\n\nslow finality\nIn the presence of fraud proofs, it is secure. In the lack of of fraud proofs, it is a non-starter because it fully loses touch with the initial assumption of &quot;the system is secure because of the L1 validators' economic security&quot;.\n\n+ FP Is proactive and secure / FAST finality / ü•∑üî´ HOMOGENOUS security\n- proactiveness is not free, but still scales well\nELVES / Sharded Execution, Shared Security / &quot;Validator waiting room&quot; analogy\n\nNotes:\n\nFraud prover is my neighboring validator, and is as secure as I am.\nFraud prover is proactively asked to check my work.\nIn case of escalation, all validators participate. Hydra analogy.\nThis leads, through game theoretic and economic rules into a system that is functionally equivalent to Shared Security, but sharded execution.\nELVES: The cost of attacking any of the L2s in this model, is as high as the cost of attacking the entire L1.\n\nx.com\nJeff Burdges (Web3 Foundation) - &quot; WIP: Efficient Block-Auditing for Blockchains&quot; - YouTube\n\nOptimistic: Go to the room of validators, and if after 2 weeks no one says that something was wrong, you are good.\nCynical: Go to the room of validators, and ask 5 random validators out of 1000 what they think. Then ask 5 more random ones what they think of the\n\n+ Secure\n- Expensive to prove, Generality\n\nNotes:\n\nCoprocessor Market Structure: Cryptoeconomic vs ZK | rob.tech\n4.1 Heated Pannel: Programmable Crypto (ZK) v.s. Programmable Trust (Restaking) - YouTube\nA technical FAQ on Lasso, Jolt, and recent advancements in SNARK design - a16z crypto\n\nCores, Parachains\n\nNotes:\n\nBringing Polkadot tech to Ethereum - Layer 2 - Ethereum Research\n\nHigher Cost, an inevitability of the proactiveness of the security that Polkadot offers\nShorter time to finality\nPossibility of implementing SPREE\nNo weakest link issue.\n\nPolkadot 2.0\n\nMake the usage of cores more flexible:\n\nAgile and On-demand\nElastic Scaling\nLower Block Times, 0.5 parachains are coming\n\nGutting and exposing Polkadot's core abilities.\nYou can only do this under the shadow of Cynical Rollups' shared security.\n.. and a very powerful VM.\n\nNotes:\nJAM is a gutting of Polkadot that exposes:\n\nDA\nOnchain\nIn-Core\n\nTo the user of each core.\n\nJAM (2)\nWhy is JAM a big deal, and a step forward?\n\n[!error]\nPersistent Fragmentation ‚ùå\n\nNotes:\nAll models so far suffer from a property that we can call persistent fragmentation. The state associated with each application must live within the boundaries of its own walled garden.\nThrough access to DA, and a fully unspecified scheduling, application that run on JAM (Services) need not suffer from persistent fragmentation, should they wish to.\nThis is a big deal, and a step forward in the space of sharded blockchain.\nJAM Resources\n\nSummary\n\nEconomically Secure? üíªüí∞\nHomogenous Economic Security ü•∑\nFragmented?üê¢\n\nHyper Optimized\n‚úÖ üôà\nN/A\n‚úÖ\n\nSharded MC\n‚úÖ üìâ\n‚ùå\n‚ùå\n\nOptimistic RU W FP\n‚úÖ\n‚ùå ~ ‚úÖ\n‚ùå\n\nOptimistic RU WO FP\n‚ùå\n‚ùå\n‚ùå\n\nSNARK Rollups\n‚úÖ\n‚ùå ~ ‚úÖ\n‚ùå\n\nCynical Rollups\n‚úÖ\n‚úÖ\n‚ùå\n\nJAM\n‚úÖ\n‚úÖ\n‚úÖ*\n\nClose\n\nQuestion: Which application is best suited to which computer?\n\nHow can we build systems that are faster but are not a time-bomb waiting for the next black swan event?\n\nStrong Opinions? Later ;)\nTalk + Recording\n\nhttps://blog.kianenigma.nl/blockchain-reimagined/presentation-tum/\n\nNote:\n\nI tried to keep this talk intentionally un-opinionated, but I do have stronger opinions ;)\n\nCome talk to me afterwards, or perhaps the panel later today.\n\nTUM Dry Run\n\nAppendix\n\nI merged PoW and PoS fully, and I argue PoW is a specialized case of PoS in which stake is paid in hardware. Come change my mind.",
		"tags": [ "note","blockchain","polkadot"]
},

{
		"title": "Building Bridges and Ecosystems - Devcon 2024",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/multichain/",
		"content": "Panel at Multichain Day.",
		"tags": [ "note"]
},

{
		"title": "Demystifying JAM - Presentation",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/demystifying-jam/presentation/",
		"content": ".reveal,\n.reveal h1,\n.reveal h2,\n.reveal h3,\n.reveal h4,\n.reveal h5,\n.reveal h6 {\nfont-family: \"PT Serif\";\n}\n.reveal .slides section img {\n\tmax-height: 70vh; /* Limit image height to 70% of the viewport height */\n\twidth: auto; /* Maintain aspect ratio */\n\t object-fit: contain !important;\n}\n\nDemystifying\n\nblog.kianenigma.com/posts/tech/demystifying-jam/presentation/\n\nNote:\nblog.kianenigma.com/posts/tech/demystifying-jam/\n\nPolkadot 1\n\nSocial\n\nOpenGov\nDOT Token ‚Üí Security\nFellowship\n\nTechnological\n\nHeterogeneous Execution Sharding, with Shared Security\n\nNote:\nSharding and heterogeneity enabled by the use of WASM.\n\nHeterogeneous Execution Sharding, with Shared Security\nLet's break it down:\n\nExecution Sharding\nWith Shared Security\nHeterogeneous\n\n--\nSequential Blockchain\n\nOpposite of execution sharding.\nHow blockchains usually work\n\n--\nPoorly Execution Sharded\n\nSharding the validator set: less security\n\n--\nExecution Sharded with Shared Security\n\nOriginal vision of ETH 2 was to be this, with 64 shards.\nELVES\n\n--\nHeterogeneous\n\nWASM bytecode\n\n--\nEvolution of Polkadot\n... is all about flexible usage of cores\n\nYou need more to get more out of your core? Async Backing!\nYou need more cores? Elastic scaling!\nYou don't want to commit to 6m? Agile-coretime!\nYou need less than one core? On-demand coretime!\nYou want to do something other than a parachain in your core? JAM!\n\nPath of a Parachain Block\n--\nPath of a Parachain Block\n\n--\nPath of a Parachain Block\n\n--\nPath of a Parachain Block\n\n--\nPath of a Parachain ::: block\n\nNotes:\n\nExecution by core validators + made available for further auditing\nState root updated by all Polkadot validators\n\n--\nOn-chain vs. In-core\n\nIn-core\n\nExecuted by a subset of validators + made available for further auditing\n\nOn-chain\n\nExecuted by all validators: state root update.\n\nIn-core, on-chain dualism in execution sharding.\n\n--\nData Availability\nPolkadot validators already attest to keeping some data available for a long (few weeks) period of time\n\nJAM\nNow you know everything to understand JAM.\n--\nJAM (0)\nGutting of Polkadot such that the following are directly exposed to developers.\n\nWhat happens In-core\nWhat happens On-chain\nWhat is placed in Data Availability\n\nNote:\nA parachain can only control what happens in-core. It cannot really control what happens on-chain. It also cannot readily add any data to the Data availability layer (well, it can, using remarks, which is a hack)\n--\nJAM (1)\n\n..and removes a lot of blockchain/parachain-centric opinions.\n\n--\nJAM (2)\n\n..and is therefore an evolution for the Polkadot Relay Chain (Cloud).\nParachains, Governance, Staking, AH and everything else remains intact.\n\nRemoving Opinions\n\nJAM is programmable via a Service.\n\nPVM Bytecode.\n\nInvocation of a service are called a Work Item[1].\n\nA group of work Items are called Work Package.\n\nNote:\n--\nIn-core and On-chain\n\nA Service is:\n\nfn refine(): What happens in-core\nfn accumulate(): What happens on-chain\nfn on_transfer(): Send messages to other services post accumulate\n--\n\nRefine\n\nMassive amounts of gas available.\nAccess to data availability (~28 day persistence)\nNo direct access to the JAM state (stateless)\n\n--\nAccumulate\n\nDirect access to the JAM state (stateful)\nLess gas available\nFully synchronous: Access the refine results of all other services, from possibly all other cores at once.\n\n--\nJAM (Recap)\nAllowing Services to program exactly how they want to use:\n\nIn-core execution\nOn-chain execution\nData availability\n\nPath of a JAM Work Package\n--\nPath of a JAM Work Package\n\nPath of a JAM Work Package\n\nPath of a JAM Work Package\n\n--\nPath of a JAM Work Package\n\n--\nPath of a JAM Work Package\n\nJAM\n\nPVM\n\nMetered\nVery fast (50% native)\nPVM instance can invoke another instance\nPause and resume\n\nCoreChains Service\nPolkadot Parachains as a JAM Service.\n\nInsights\n(personal opinion)\n\nWhat is best implemented as a service?\n\nLow level\nCrucial to get this right\n\nPolkadot has JAM within it, but it is &quot;fixed&quot;\nServices &lt;&gt; Interoperability\nSemi-coherence\nNo transactions? Great!\n\nNote:\n\nServices will likely not be equivalent to smart contract or even parachains; Think more along the lines of &quot;Kernel functions&quot;.\n\nCrucial to get this right\n\nService interoperability? Wrong question.\nSemi-Coherence. Good!\nPolkadot has all the JAM components, but they are fixed.\nLess is more: No transactions? Good!\ncome to think of it, a smart contract can have arbitrary, user-defined entry-points. A service is not.\n\n--\nQuestions\n\nAppendix\n\nKernel Update Analogy\n\nNote:\nHardware is what provides compute and bandwidth, and the kernel is part of the OS that moderates the hardware access.\nCurrent Polkadot. A lot of stuff is part of the &quot;Kernel/OS&quot;.\n--\n\n--\n\n--\nWork Item\ngraph LR\n\tsubgraph WorkPackage\n\t\tWI1[Work Item 1]\n\t\tWI2[Work Item 2]\n\t\tWI3[Work Item 3]\n\tend\n\tsubgraph WorkReport\n\t\tWR1[Work Result 1]\n\t\tWR2[Work Result 2]\n\t\tWR3[Work Result 3]\n\tend\n\t\n\tWI1 --> WR1\n\tWI2 --> WR2\n\tWI3 --> WR3\n\nAnd depending on the context, Work Package, Work Result and Work Report. ‚Ü©Ô∏é",
		"tags": [ "note","polkadot","jam"]
},

{
		"title": "Plaza Polkadot Hub - OpenGiuld Community Call",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/2024/plaza-polkadot-hub-open-giuld-community-call/",
		"content": "December 13th 2024\nRecording: https://x.com/i/broadcasts/1rmxPoAaoBLJN",
		"tags": [ "note"]
},

{
		"title": "Podcast - Kusamarian",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/2024/podcast-kusamarian/",
		"content": "",
		"tags": [ "note"]
},

{
		"title": "Polkadot Blockchain Academy Hong Kong",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/2024/polkadot-blockchain-academy-hong-kong/",
		"content": "Hong Kong cohort Jan 2024\n\nCryptography Module\nEconomics Module\nBlockchain Module\nSmart Contracts Module\nSubstrate Module\nFRAME Module\nPolkadot Module\nXCM Module\n\nPolkadot Blockchain Academy - PBAX\nSlides: Polkadot Blockchain Academy",
		"tags": [ "note"]
},

{
		"title": "Polkadot-SDK FRAME @ 2024",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/frame-2024/",
		"content": ".reveal,\n.reveal h1,\n.reveal h2,\n.reveal h3,\n.reveal h4,\n.reveal h5,\n.reveal h6 {\nfont-family: \"PT Serif\";\n}\n.reveal {\n--r-main-font-size: 32px;\n}\n.reveal .slides section img {\n\tmax-height: 70vh; /* Limit image height to 70% of the viewport height */\n\twidth: auto; /* Maintain aspect ratio */\n\t border-bottom: 1px dashed rgba(0, 0, 0, 0.5);\n\t border-radius: 50px;\n\t padding: 20px;\n}\n\nPolkadot SDK and FRAME\n\nin 2024\nblog.kianenigma.com/talks/frame-2024\n\nNote:\n\nStable + Meaningful Releases\n--\nPast\n\nsubstrate, cumulus, polkadot (which contained xcm)\nGit based dependency\nYOLO-major bump everything at all times.\n\n--\nNow\n\n--\nNow\n\nstableYYMM\n\nEvery 3 month, maintained for 1 year with a monthly patching schedule.\nPRs need to specify major/minor/patch on the crates they alter.\nNo change? no bump üëÜ\n\nparitytech/release-registry\n\nGetting Started\n\n--\nTemplates\n\nMaintained by Parity as part of polkadot-sdk, always updated with our stable releases.\n\npolkadot-sdk-parachain-template\npolkadot-sdk-solochain-template\npolkadot-sdk-minimal-template\nAll updated automatically after each stableYYMM release.\nUn-opinionated\n\nExternal opinionated templates also listed, open to more suggestions.\n\nPoP\nOpenZeppelin\n\nNotes:\n\nMake `polkadot-sdk` templates OMNI and GREAT again -- part 2 ¬∑ Issue #5242 ¬∑ paritytech/polkadot-sdk ¬∑ GitHub\n\nWe notice a cunning simplification in the template's Cargo.toml for the runtime.. ü§î\n\n--\nUmbrella Crates\n[dependencies]\ncodec = { workspace = true }\nscale-info = { workspace = true }\npolkadot-sdk = { version = &quot;x.y.z&quot;, features = [\n\t&quot;pallet-balances&quot;, &quot;pallet-sudo&quot;, &quot;pallet-timestamp&quot;, &quot;runtime&quot;]\n}\n\n[features]\ndefault = [&quot;std&quot;]\nstd = [\n\t&quot;codec/std&quot;,\n\t&quot;scale-info/std&quot;,\n\t\n\t&quot;polkadot-sdk/std&quot;,\n]\n\n--\npolkadot-sdk Crate\n\nUmbrella crate to declutter your Cargo.toml\nLess confusion with which version to use\n\nAnd enablement of features like std, runtime-benchmark, try-runtime\n\n--\npolkadot-sdk Crate\n\nWill it kill my compile time?\nMigration: use polkadot_sdk::*, the rest of your code remains as-is.\n\nNote:\n\nCompile time: A bit, but not too bad. feature = node, feature = runtime\npolkadot_sdk_docs::reference_docs::umbrella_crate - Rust\n\n--\n\nThen, if we look at the runtime/lib.rs, we also notice less clutter ü§î\n--\n\npolkadot-sdk-frame Crate\n#![cfg_attr(not(feature = &quot;std&quot;), no_std)]\n\nextern crate alloc;\nuse alloc::{vec, vec::Vec};\n\nuse polkadot_sdk::{polkadot_sdk_frame as frame, *};\nuse frame::{\n\tprelude::*,\n\truntime::{apis, prelude::*},\n};\n\n--\npolkadot-sdk-frame Crate\n\npolkadot-sdk simplifies your Cargo.toml\npolkadot-sdk-frame simplifies your runtime and pallet lib.rs by providing sensible preludes.\n\nNote:\npolkadot_sdk_frame - Rust\nFetching Title#nysy\n--\nPast (substrate-node-template)\n--\n\nAPI Documentation\n\nSimple, underrated, important enabler.\nFundamental types and macros now all have API documentation, with correct and extensive examples\n\npallet::call, pallet::storage\n\n--\n\n--\n\nNote:\n\nframe_support::pallet_macros - Rust\nstorage in frame_support::pallet_macros - Rust\n--\n\nAPI Documentation:\n\nall released crates: docs.rs\nmaster: https://paritytech.github.io/polkadot-sdk/\n\n‚ö†Ô∏è One doc-only crate cannot yet be published and is only visible in the latter.\n\nNote:\n\npolkadot_sdk_docs - Rust\n\n--\nAPI Documentation:\n\nThese docs are tightly integrated with polkadot-sdk\nTHEY CANNOT GET OUTDATED!\n\nReflection\nAll of this, releases, stable and well-documented API, is to say polkadot-sdk is a step closer to a mature mono-repo.\n\nand we shall keep it that way.\n\nFRAME Updates\n\nEasier getting started: dev_mode\nEasier test setup: [config(with_default)] and #[derive_impl()]\nSyntax: #[runtime] macro\nAdvanced: #[pallet::task]\nAdvanced: #[pallet::feeless_if]\nAdvanced: #[pallet::view_function] Soon‚Ñ¢Ô∏è\n\nAll of this is opt-in.\n--\nBefore\nimpl frame_system::Config for Test {\n\ttype BaseCallFilter = ();\n\ttype BlockWeights = ();\n\ttype BlockLength = ();\n\ttype DbWeight = ();\n\ttype RuntimeOrigin = RuntimeOrigin;\n\ttype RuntimeCall = RuntimeCall;\n\ttype Nonce = u64;\n\ttype Block = Block;\n\ttype Hash = sp_core::H256;\n\ttype Hashing = sp_runtime::traits::BlakeTwo256;\n\ttype AccountId = AccountId;\n\ttype Lookup = IdentityLookup&lt;Self::AccountId&gt;;\n\ttype RuntimeEvent = RuntimeEvent;\n\ttype Version = ();\n\ttype PalletInfo = PalletInfo;\n\ttype AccountData = ();\n\ttype OnNewAccount = ();\n\ttype OnKilledAccount = ();\n\ttype SystemWeightInfo = ();\n\ttype SS58Prefix = ();\n\ttype OnSetCode = ();\n\ttype MaxConsumers = ConstU32&lt;16&gt;;\n}\n\n--\nAfter\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig)]\nimpl frame_system::Config for Test {\n\ttype Block = frame_system::mocking::MockBlock&lt;Test&gt;;\n}\n\nOr\n#[derive_impl(frame_system::config_preludes::TestDefaultConfig)]\nimpl frame_system::Config for Test {\n\ttype Block = frame_system::mocking::MockBlock&lt;Test&gt;;\n\ttype AccountData = pallet_balances::AccountData&lt;u64&gt;;\n}\n\nNode\n\nHow cool would it be to download a node that could run any wasm runtime?\n\nNo need to maintain it, update it, etc.\nNo need to compile it ü´†\n\n--\nOmni Node\n\nCapable of running (most) parachains, and a local dev chain.\nEarly docs\nFirst iteration will be released with stable2412\n\nClosing Remarks\n\nA lot of what I have said are initiatives that need contributors to push through the finish line!\n\nMentor-able, tip-able issues in the speaker notes\n\nDeveloping a blockchain with Polkadot-SDK has gotten even simpler now, but..\n\nContracts will always be easier!\n\nNote:\n\nAll good-first issues: Issues ¬∑ paritytech/polkadot-sdk ¬∑ GitHub\nAll mentor issues: Issues ¬∑ paritytech/polkadot-sdk ¬∑ GitHub",
		"tags": ["5242", "note"]
},

{
		"title": "Demystifying JAM - PBA6",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/posts/tech/demystifying-jam/presentation-pba/",
		"content": ".reveal,\n.reveal h1,\n.reveal h2,\n.reveal h3,\n.reveal h4,\n.reveal h5,\n.reveal h6 {\nfont-family: \"PT Serif\";\n}\n.reveal .slides section img {\n\tmax-height: 60vh; /* Limit image height to 70% of the viewport height */\n\twidth: auto; /* Maintain aspect ratio */\n\t object-fit: contain !important;\n}\n\nblog.kianenigma.com/posts/tech/demystifying-jam/\n\nNote:\n\nblog.kianenigma.com/posts/tech/demystifying-jam/presentation-pba\nhttps://blog.kianenigma.com/posts/tech/demystifying-jam/presentation/\nblog.kianenigma.com/posts/tech/demystifying-jam/\n\nThis Talk\n\nUnderstand what JAM is\nJAM's role in the broader Web3 vision\n\nUnderstanding What JAM Is\n\naka. Demystifying JAM\n\nPolkadot 1\n\nSocial\n\nOpenGov\nDOT Token ‚Üí Security\nFellowship\n\nTechnological\n\nHeterogeneous Execution Sharding, with Shared Security\n\nNote:\nSharding enabled by the use of ELVES, and heterogeneity enabled by the use of WASM.\nELVES: Efficient Execution Auditing for Blockchains under Byzantine Assumptions\n\nHeterogeneous Execution Sharding, with Shared Security\nLet's break it down:\n\nExecution Sharding\nWith Shared Security\nHeterogeneous\n\n--\nSequential Blockchain\n\nNotes:\n\nOpposite of execution sharding\nHow blockchains usually work\n\n--\n(Poorly) Execution Sharded\n\nSharding the validator set: less security\n\n--\nExecution Sharded with Shared Security\n\nELVES and Cynical Rollups\nCore Model\n\nNote:\nOriginal vision of ETH 2 was to be this, with 64 shards.\n--\nHeterogeneous\n\nWASM bytecode\n\n--\nNow You Get It?\n\nExecution Sharding + With Shared Security + Heterogeneous\n--\nEvolution of Polkadot\n... is all about flexible usage of cores\n\n¬≠You need more to get more out of your core? Async Backing!\n¬≠You need more cores? Elastic scaling!\n¬≠You don't want to commit to 6m? Agile-coretime!\n¬≠You need less than one core? On-demand coretime!\n¬≠You want to do something other than a parachain in your core? JAM!\n\nPath of a Parachain Block\n--\nPath of a Parachain Block\n\n--\nPath of a Parachain Block\n\n--\nPath of a Parachain Block\n\nNote:\nIn the existing Polkadot, the block itself is put into the DA for further auditing.\n--\nPath of a Parachain Block\n\nNotes:\n\nExecution by core validators + made available for further auditing\nState root updated by all Polkadot validators\n\n--\nPolkadot's Primitives\n\nIn-core execution, with access to DA\nOn-chain execution, with access to the main Polkadot state\n\n--\nPolkadot's Primitives\n\nPolkadot currently allows you to do a limited thing in-core, and on-chain. What are they?\n\nIn-chain: Re-execute the PVF, make the PoV accessible to DA\nOn-core: Small signature updates\n\n--\nAside: Blockspace vs. Coretime\n\nIn-core, on-chain dualism is unique to execution sharding\n\nNote:\nThis is why the word blockspace, despite being wildly adopted, is not very sensible in Polkadot, because we have various modes of blockpsace. This is why the word coretime is sometimes used instead of blockspace.\n\nJAM\nNow you know everything to understand JAM.\n--\nJAM (0)\nGutting of Polkadot such that the following are directly exposed to developers.\n\nWhat happens In-core\nWhat is placed in Data Availability from the core\nWhat happens On-chain\n\nNote:\nA parachain can only control what happens in-core. It cannot really control what happens on-chain. It also cannot readily add any data to the Data availability layer (well, it can, using remarks, which is a hack)\n--\nJAM (1)\n\n..and removes a lot of parachain-centric opinions from Polkadot's core protocol.\n\n--\nJAM (2)\n\n..and is therefore an evolution for the Polkadot Relay Chain.\nParachains, Governance, Staking, AssetHub and everything else remains intact.\n\nRemoving Opinions\n\nJAM is programmable via a Service (PVM Bytecode)\nInvocation of a service are called a Work Item\n\nA group of work Items are called Work Package.\n\nNote:\n--\nIn-core and On-chain\n\nA Service is:\n\nfn refine(): What happens in-core\nfn accumulate(): What happens on-chain\nfn on_transfer(): Send messages to other services post accumulate\n--\n\nRefine\n\nMassive amounts of gas available (5s PVM)\nCan receive up to 12MB of input data (from DA, or extrinsic data)\nAccess to data availability\n\n1.5 PB maximum size / 6s propagation time\n\nNo direct access to the JAM state (stateless)\n\n--\nAccumulate\n\nDirect access to the JAM state (stateful)\nLess gas available (10ms PVM)\nFully synchronous: Access the refine results of all other services, from possibly all other cores at once.\n\n--\nJAM (Recap)\nAllowing Services to program exactly how they want to use:\n\nIn-core execution\nOn-chain execution\nData availability\n\nPath of a JAM Work Package\n--\nPath of a JAM Work Package\n\nPath of a JAM Work Package\n\nPath of a JAM Work Package\n\n--\nPath of a JAM Work Package\n\n--\nPath of a JAM Work Package\n\nJAM\n\nPVM\n\nMetered (benchmarking ü§¢)\nVery fast (45% native)\nPVM instance can invoke another instance\n\nService can invoke a parachain, or smart contract, or anything else\n\nEasy to pause and resume -&gt; Continuation\n\nJAM Misc\n\nJAM offers a similar bulk/on-demand coretime purchase model to that of Polkadot\n\nNo per-transaction purchase\nMuch greater economic freedom for services/applications!\n\n--\nJAM Misc (1)\n\nJAM offers a much more flexible Authorization mechanism for core utilization\n\nauthorize() -&gt; refine() -&gt; accumulate() -&gt; on_transfer()\n\n--\nJAM Misc (2)\n\nJAM's data model: Mostly coherent with transient decoherence\n\nJAM Envisioned Services\n\nCoreChains\nCoreVM / CoreBoot / JAMDocker\nCorePlay\n\n--\nCoreChains\n\nEntire Polkadot 2 + Parachains is one service\n\nNote: This is an example of JAM's low abstraction level\n--\nCoreVM\n\nRunning normal applications on JAM\nDemonstration of PVM's &quot;continuation&quot;\nUtilizes DA to store intermediate program state, such as the stack and registers\nüéØ DOOM!\n\n--\nCorePlay\n\nUltimate actor based smart contract platform\nNon-persistent state partitioning\n\nNote: This is a prime example of JAM's transient decoherence in action\n--\nCorePlay\n\nJAM Introduction Ends\nQuestions?\n\nThe Web3 Vision and JAM\n\nNotes about blockchain/Web3 technology\nNotes about blockcha in/Web3 vision\n\nBlockchain Technology\n\nBlockchain Mental Models\n\n¬≠ü§Æ Database\n¬≠‚ôæÔ∏è State Machine\n¬≠ üíªComputer\n\n--\nBlockchain Mental Models\n\nA computer has two main primitives\n\n‚öôÔ∏è Computation\nüíø Storage\n\n--\nGeneric Blockchain Computer\n\nA blockchain/Web3 computer has:\n\n‚öôÔ∏è + üëÆ‚Äç‚ôÇÔ∏è Secure computation\n\nCanonical ordering + auditability of the said secure computation\n\nSecure, public-by-default storage\n--\n\nSequential, Non-Sharded Blockchain Computer\n\nLimited + Expensive computation\nLimited + Expensive storage\nFully coherent environment, albeit kinda useless\n\n--\nSharded Blockchain Computer\n\nAbundant computation\nAbundant storage\n\nLimited + Expensive coherent L1 storage\nAbundant incoherent rollup storage\n\nFully incoherent environment, which still makes it kinda useless\nMulti-core CPU, without any shared memory!\n\nNote:\nThis model is potentially useful, if you want a lot of throughput, high customization, and don't care much about interoperability\n--\nJAM: Supercomputer\n\nJAM is a supercomputer. It is most performant Web3 computer one can build, without sacrificing security\n\n--\nJAM: Supercomputer\n\nAbundant secure computation (ELVES)\nAbundant storage\n\nLimited coherent L1 storage (JAM State)\nAbundant, mostly coherent DA storage (D3L)\nFully incoherent service storage\n\n--\nJAM: Web3 Cloud\n\nJAM is like supercomputer that takes the has the most high quality primitives of the Web3 computer, and exposes them all to developers\nJAM is the (virtual) Web3 hardware on top of which we can build what we may dare call Web3 Cloud.\n\nWeb3 Vision\n\nAnd this brings us to the billion dollar question of: What can we build with a Web3 cloud platform?\n\n--\nWeb3 Vision\n\nPersonal opinion follows\n\nNot materialized\nNot understood by all in the same way, is evolving, industry is dividing into branches\n\n--\nWeb3 Vision: What Are We Lacking?\n\n¬≠Start with &quot;why&quot;? Resilience + centralization corrupts\n¬≠Form your own &quot;why&quot;: Based on moral and technical reasons üìö\n¬≠The properties of the Web3 cloud is drastically different than that of Web2 cloud, even if they sound similar\n\nNote:\nWe as an industry, need to have a much better understanding of what task the tool which we are building is best fitted to solve\n--\nBack to Basics: Secure Computation\n\nSecure computation. Why would we need this?\n¬≠Only social, multi-party contentious and/or value-bearing interactions can benefit from secure computation\n¬≠My data, my interactions with it? Web2. Evolution of it is self-hosted\n\nNote:\nIf only I am interacting with the system? doubtful\nIf someone else is interacting with it, but running it my own server is enough? doubtful\nExample: 1Password on a blockchain? You got something wrong there bro\n--\nBack to Basics: Exercise\n\nGo over your list of applications in your phone, and name in which app your need to interact with another humans, and the app and platform is sitting in the middle?\nName in which the platform is at a position where it can misuse its position?\n\nNote:\nDocusSign, Donations, Petitions, AppStore, Youtube Monetization, Public-key-infrastructure\n--\nBack To Basics: Other Examples\n\n¬≠Not only social, but preferably digital: &quot;The Oracle Problem&quot;\n¬≠Secure Computation != Blockchain. Consortium systems\n¬≠Public data and computation, unless FHE/ZK/MPC is used\n\nQuestions\n\nAppendix / Backup Slides\n--\nKernel Update Analogy\n\nNote:\nHardware is what provides compute and bandwidth, and the kernel is part of the OS that moderates the hardware access.\nCurrent Polkadot. A lot of stuff is part of the &quot;Kernel/OS&quot;.\n--\n\n--\n\n--\nWork Item\ngraph LR\n\tsubgraph WorkPackage\n\t\tWI1[Work Item 1]\n\t\tWI2[Work Item 2]\n\t\tWI3[Work Item 3]\n\tend\n\tsubgraph WorkReport\n\t\tWR1[Work Result 1]\n\t\tWR2[Work Result 2]\n\t\tWR3[Work Result 3]\n\tend\n\t\n\tWI1 --> WR1\n\tWI2 --> WR2\n\tWI3 --> WR3",
		"tags": [ "note","polkadot","jam","pba"]
},

{
		"title": "Smart Contracts 101",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/2025/smart-contracts-101/",
		"content": ".reveal,\n.reveal h1,\n.reveal h2,\n.reveal h3,\n.reveal h4,\n.reveal h5,\n.reveal h6 {\nfont-family: \"PT Serif\";\n}\n.reveal {\n--r-main-font-size: 32px;\n}\n.reveal .slides section img {\n\tmax-height: 30vh; /* Limit image height to 70% of the viewport height */\n\twidth: auto; /* Maintain aspect ratio */\n\t border-radius: 50px;\n\t padding: 20px;\n}\n\nPolkadot Smart Contracts\n\nAbout Me\n\nKian Paimani aka. @kianenigma\nEngineering Lead @ Parity Technologies\nPolkadot Core Fellow\nblog.kianenigma.com (&lt;-- slides)\n\nWhat is a Smart Contract\nBlockchain models that we can think of:\n\nDatabase ü§Æ\nState Machine ‚ôæÔ∏è\nComputer üíª\n\nNote:\nFirst is utter BS\nSecond is accurate, but a bit to math-y\nThird one is accurate, and one that most people relate to, we will use this one\n--\nWhat is a Smart Contract\n\nComputer has code and memory.\nUsers can interact with the code (trigger a transfer üí∏)\nmemory stores valuable information (how much money I own ü§ë)\nIn a blockchain, we call these the stf/runtime, and state respectively.\n\nAside: The main novelty of a computer is that it will execute code correctly, and therefore you can TRUST the memory. ü™Ñ\n\n--\nWhat is a Smart Contract\n\nFirst generation blockchains had a fixed code.\nWhat is the code of the Bitcoin computer?\n\nTransfer of BTC\n\nNote:\nFirst blockchains were computers with a (almost) fixed code. Bitcoin's code is ONLY how to do transfer of BTC, and therefore the State of the Bitcoin computer was only user balances. Nothing more.\n--\nWhat is a Smart Contract\n\nSmart Contracts are the first step into making blockchain computers programmable.\n\n--\nWhat is a Smart Contract\n\nEthereum is a programmable blockchain\nWhat is the code of the Ethereum computer?\n\nTransfer of ETH\nUpload a contract\nCall into an existing contract, which might alter state\n\n--\nWhat is a Smart Contract\n\n--\nWhat is a Smart Contract\n\nGiven: blockchains are computers with code and memory\nSmart contracts are essentially a way to extend the code and memory\n\n--\nWhat is a Smart Contract\n\nExecution of these contracts is as secure as the execution of the main blockchain's code. ü™Ñ\nIf you can trust Ethereum and its ability to correctly transfer ETH, you should also trust that it can correctly execute whatever is the code of any smart contract.\n\nEthereum Contracts\nA Smart Contract has:\n\ncode\naddress (at which it can be invoked)\nstate/memory\nbalance: money owned by the contract\n\nNote:\nBringing it all together\n\nCase Study\nSimple Escrow Contract\n\nBuyer deposits funds\nBoth buyer and seller approve\n\nTransfer funds to seller\n\nTimeout\n\nReturn funds to buyer\n\n--\nCase Study\nWeb3 Roulette\n\nDeposit Phase\n\nAnyone can deposit money into the contract\n\nRoulette Phase\n\nOne participants get nothing back, their money split among everyone else\n\nHow to Write a Contract\n\nEthereum Contracts are written in a language Solidity.\nPart of the Ethereum code is to execute Solidity code.\nThis happens in a virtual machine known as EVM\n\nNote:\nEVM: Ethereum Virtual Machine\n\nHow to Execute a Contract\nIf Ethereum wants to execute a totally untrusted code, what challenges does it have?\n\nDeterministic cost (gas)\nDeterministic output (EVM)\n\n--\nHow to Execute a Contract\n\nAbility to meter ‚è∞ the cost of the execution of a contract is an important requirement\nThis is why when interacting with any contract, you specify gas_limit\n\n--\nExtending Memory\nWhat about the fact that a contract can add more data to its own memory, which in turn bloats the overall blockchain memory?\n\nState cost needs to be taken into account\n\nPart of gas\nDeposit\nState Rent\n\n--\nOther Properties of Contracts\n\nAtomic\nImmutable\n\nSmart Contracts in Polkadot\n\nPolkadot\n\nComputer who's code allows other Blockchains to be executed and validated.\nPolkadot always assumed one of these external blockchains (Parachains) would deliver smart contract capability.\n\nPast\n\nPolkadot's code is WASM bytecode (not EVM or similar).\nAn experiment to compile Rust to WASM as a smart Contract\n\npallet-contracts and Ink!.\n\nExecute EVM compatible Smart Contracts as well\n\npallet-evm\n\nNote:\nBoth of these initiated in Parity, but are pursued as community projects now.\n\nNow\n\nA new, much better virtual machine based on RiskV: PolkaVM\nFork pallet-contracts to execute any Smart Contract that compiles to PolkaVM.\nCompiler to compile Solidity to PolkaVM bytecode\n\n--\nNow\nOutcome: Polkadot will have fast Solidity-compatible Smart Contracts in H2 2025\n\nOutro\n\nSmart Contracts are the most basic form of building an application on top of a secure blockchain computer ü™Ñ.\nBattle tested approach that has been used for almost a decade now\n\nQuestions",
		"tags": [ "note"]
},

{
		"title": "Introduction to Polkadot",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/fa/polkadot/",
		"content": "",
		"tags": [ "note"]
},

{
		"title": "Random Rust Video Tutorials",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/fa/rust/",
		"content": "",
		"tags": [ "note"]
},

{
		"title": "Talks Index",
		"date":"Tue Apr 08 2025 12:02:40 GMT+0000 (Coordinated Universal Time)",
		"url":"/talks/talks-index/",
		"content": "[!tip] Youtube Channel.\n\nFile\nDate\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/presentation-pba/\">Demystifying JAM - PBA6</a>\nApr 01 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2025/smart-contracts-101/\">Smart Contracts 101</a>\nJan 13 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2024/podcast-kusamarian/\">Podcast - Kusamarian</a>\nJan 05 2025\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2024/plaza-polkadot-hub-open-giuld-community-call/\">Plaza Polkadot Hub - OpenGiuld Community Call</a>\nDec 13 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/multichain/\">Building Bridges and Ecosystems - Devcon 2024</a>\nNov 22 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/posts/tech/demystifying-jam/presentation/\">Demystifying JAM - Presentation</a>\nNov 06 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/frame-2024/\">Polkadot-SDK FRAME @ 2024</a>\nNov 06 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/blockchain-reimagined/presentation-tum/\">Blockchain Scalability - A Holistic Recap</a>\nSep 08 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/2024/polkadot-blockchain-academy-hong-kong/\">Polkadot Blockchain Academy Hong Kong</a>\nJun 27 2024\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/nomination-pools/\">Nomination Pools</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/polkadot-npos/\">Polkadot's Nominated Proof of Stake</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/phragmen/\">Phragm√©n for Polkadot's NPoS</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/phragmen2/\">Phragm√©n Overview</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/fa/polkadot/\">Introduction to Polkadot</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/substrate-debug-kit/\">Substrate Debug Kit</a>\nAug 28 2023\n\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/talks/fa/rust/\">Random Rust Video Tutorials</a>\nAug 28 2023",
		"tags": [ "note"]
}
]